<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yinan的博客</title>
  
  
  <link href="https://yinan.fun/atom.xml" rel="self"/>
  
  <link href="https://yinan.fun/"/>
  <updated>2023-08-06T03:31:42.675Z</updated>
  <id>https://yinan.fun/</id>
  
  <author>
    <name>yinan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电饭煲叉烧</title>
    <link href="https://yinan.fun/%E7%94%B5%E9%A5%AD%E7%85%B2%E5%8F%89%E7%83%A7"/>
    <id>https://yinan.fun/%E7%94%B5%E9%A5%AD%E7%85%B2%E5%8F%89%E7%83%A7</id>
    <published>2023-08-06T03:29:27.000Z</published>
    <updated>2023-08-06T03:31:42.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电饭煲叉烧">电饭煲叉烧</h1><p><ahref="https://www.bilibili.com/video/BV1yV4y187H9">https://www.bilibili.com/video/BV1yV4y187H9</a></p><h3 id="准备梅花肉">准备梅花肉</h3><blockquote><p>可以用五花肉替代</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129526.png"alt="一斤二两梅花肉" /><figcaption aria-hidden="true">一斤二两梅花肉</figcaption></figure><h3 id="有点厚用牙签扎扎孔">有点厚，用牙签扎扎孔</h3><blockquote><p>腌的时候切几大块，然后用叉子正反插猪肉，这样更能入味</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061107984.png"alt="image-20230806110717962" /><figcaption aria-hidden="true">image-20230806110717962</figcaption></figure><h3 id="腌制肉">腌制肉</h3><blockquote><p>蜂蜜可以用冰糖替代</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061110146.png"alt="image-20230806111004086" /><figcaption aria-hidden="true">image-20230806111004086</figcaption></figure><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129621.png"alt="image-20230806110857406" /><figcaption aria-hidden="true">image-20230806110857406</figcaption></figure><h3id="套上袋子放冰箱冷藏腌制三个小时以上">套上袋子，放冰箱冷藏腌制三个小时以上</h3><blockquote><p>最好过夜腌制</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129764.png"alt="image-20230806111136504" /><figcaption aria-hidden="true">image-20230806111136504</figcaption></figure><h3id="第二天全部倒入电饭煲按煮饭键">第二天全部倒入电饭煲，按煮饭键</h3><blockquote><p>电饭锅就不用加水了，不粘锅也不加水，铁锅要加一些水的。</p><p>普通电饭锅直接煮饭键模式就行了！如果切的厚，煮饭键结束，你看着没熟，可以再煮一会。一般电饭锅煮饭键都是40分钟吧</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129019.png"alt="image-20230806111235934" /><figcaption aria-hidden="true">image-20230806111235934</figcaption></figure><h3 id="时间到放入锅里收汁">时间到放入锅里收汁</h3><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129554.png"alt="image-20230806111421930" /><figcaption aria-hidden="true">image-20230806111421930</figcaption></figure><h3 id="不断用勺子往叉烧上淋汁">不断用勺子往叉烧上淋汁</h3><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129739.png"alt="image-20230806111536851" /><figcaption aria-hidden="true">image-20230806111536851</figcaption></figure><h3 id="收到浓稠挂汁的状态">收到浓稠挂汁的状态</h3><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129948.png"alt="image-20230806111701219" /><figcaption aria-hidden="true">image-20230806111701219</figcaption></figure><h3 id="斜刀切">斜刀切</h3><blockquote><p>尽量薄一点</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129154.png"alt="image-20230806111848910" /><figcaption aria-hidden="true">image-20230806111848910</figcaption></figure><h3 id="装盘">装盘</h3><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308061129908.png"alt="image-20230806112715143" /><figcaption aria-hidden="true">image-20230806112715143</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电饭煲叉烧&quot;&gt;电饭煲叉烧&lt;/h1&gt;
&lt;p&gt;&lt;a
href=&quot;https://www.bilibili.com/video/BV1yV4y187H9&quot;&gt;https://www.bilibili.com/video/BV1yV4y187H9&lt;/a&gt;&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="吃的" scheme="https://yinan.fun/categories/%E5%90%83%E7%9A%84/"/>
    
    
    <category term="电饭煲" scheme="https://yinan.fun/tags/%E7%94%B5%E9%A5%AD%E7%85%B2/"/>
    
    <category term="肉" scheme="https://yinan.fun/tags/%E8%82%89/"/>
    
  </entry>
  
  <entry>
    <title>概率评分方法</title>
    <link href="https://yinan.fun/%E6%A6%82%E7%8E%87%E8%AF%84%E5%88%86%E6%96%B9%E6%B3%95"/>
    <id>https://yinan.fun/%E6%A6%82%E7%8E%87%E8%AF%84%E5%88%86%E6%96%B9%E6%B3%95</id>
    <published>2023-08-05T08:03:51.000Z</published>
    <updated>2023-08-05T08:24:28.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概率评分方法">概率评分方法</h1><p>一般来说，<strong>评估预测概率准确性</strong>的方法被称为评分规则或评分函数。下面将介绍三种评分方法，可用于评估<strong>分类预测建模</strong>问题的预测概率。</p><h2 id="log-loss-score">Log Loss Score</h2><p>Log loss, also called “logistic loss,” “logarithmic loss,” or “crossentropy” can be used as a measure for evaluating predictedprobabilities.</p><p>将每个预测概率与实际类输出值（0或1）进行比较，并计算出一个分数，该分数根据与预期值的距离来惩罚概率。惩罚是对数的，小差异的分数小和大差异的分数大。</p><p>对于带有真实标签的单个样品 <span class="math inline">\(y \in\{0,1\}\)</span> 和概率估计 <span class="math inline">\(p =\operatorname{Pr}(y = 1)\)</span>, log loss 是： <spanclass="math display">\[L_{\log}(y, p) = -(y \log (p) + (1 - y) \log (1 - p))\]</span></p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308051604385.png"alt="Log loss图像" /><figcaption aria-hidden="true">Log loss图像</figcaption></figure><h3 id="缺点">缺点</h3><p>Logloss的结果对数据集取平均，在平衡数据集的情况下，分数将是合适的，在不平衡数据集的情况下，分数将具有误导性。</p><p>平衡数据集Log Loss预测的折线图</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308051604968.png"alt="平衡数据集Log Loss预测的折线图" /><figcaption aria-hidden="true">平衡数据集LogLoss预测的折线图</figcaption></figure><p>不平衡数据集（0多）Log Loss预测的折线图</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308051604640.png"alt="不平衡数据集Log Loss预测的折线图" /><figcaption aria-hidden="true">不平衡数据集LogLoss预测的折线图</figcaption></figure><h3 id="实现">实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sklearn.metrics.log_loss(y_true, y_pred, *, eps=<span class="hljs-string">&#x27;auto&#x27;</span>, normalize=<span class="hljs-literal">True</span>, sample_weight=<span class="hljs-literal">None</span>, labels=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><ahref="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.log_loss.html">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.log_loss.html</a></p><h2 id="brier-score">Brier Score</h2><p>BrierScore衡量的是预测概率和实际结果之间的<strong>均方差</strong>。分数汇总了概率预测中误差的大小。错误分数始终在0.0和1.0之间，其中完美的模型的分数为0。</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308051604434.png"alt="Brier Score图像" /><figcaption aria-hidden="true">Brier Score图像</figcaption></figure><h3 id="实现-1">实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sklearn.metrics.brier_score_loss(y_true, y_prob, *, sample_weight=<span class="hljs-literal">None</span>, pos_label=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><ahref="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.brier_score_loss.html">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.brier_score_loss.html</a></p><p>与Log loss一样，在不平衡数据集的情况下，分数将具有误导性。</p><h2 id="roc-auc-score">ROC AUC Score</h2><p>ROC（Receiver OperatingCharacteristic）曲线是一种用于表示分类模型性能的图形工具。它通过将<strong>真阳性率（TruePositive Rate，TPR）</strong>和<strong>假阳性率（False PositiveRate，FPR）</strong>作为横纵坐标来描绘分类器在<strong>不同阈值</strong>下的性能。</p><blockquote><p>真阳性率（True PositiveRate，TPR）是指分类器正确识别正例的能力，可以理解为所有阳性群体中被检测出来的比率，TPR越接近1越好。</p><p>假阳性率（False PositiveRate，FPR）是指在所有实际为负例的样本中，模型错误地预测为正例的样本比例，FPR越接近0越好。</p></blockquote><p><span class="math display">\[TPR=\frac{TP}{P}=\frac{TP}{TP+FN}\\FPR=\frac{FP}{N}=\frac{FP}{FP+TN}\]</span></p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308051604179.png"alt="混淆矩阵图" /><figcaption aria-hidden="true">混淆矩阵图</figcaption></figure><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308051624977.png"alt="ROC曲线" /><figcaption aria-hidden="true">ROC曲线</figcaption></figure><p><code>sklearn</code> <code>LogisticRegression</code> 的ROC曲线：</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308051604070.png"alt="LogisticRegression的ROC曲线" /><figcaption aria-hidden="true">LogisticRegression的ROC曲线</figcaption></figure><p>AUC（Area Under rocCurve）是<strong>ROC曲线下的面积</strong>，用于衡量分类器性能。AUC值越接近1，表示分类器性能越好；反之，AUC值越接近0，表示分类器性能越差。在实际应用中，我们常常通过计算AUC值来评估分类器的性能。</p><p>ROC曲线围成的面积(即AUC)可以解读为：从所有正例中随机选取一个样本A，再从所有负例中随机选取一个样本B，分类器将A判为正例的概率比将B判为正例的概率大的可能性。</p><blockquote><p><strong>AUC的一般判断标准：</strong></p><p>0.5 - 0.7：效果较低，但用于预测股票已经很不错了</p><p>0.7 - 0.85：效果一般</p><p>0.85 - 0.95：效果很好</p><p>0.95 - 1：效果非常好，但一般不太可能</p></blockquote><h3 id="优点">优点</h3><p>TPR用到的TP和FN同属P列，FPR用到的FP和TN同属N列，所以即使P或N的整体数量发生了改变，也不会影响到另一列。也就是说，即使正例与负例的比例发生了很大变化，ROC曲线也不会产生大的变化，而像Precision使用的TP和FP就分属两列，则易受类别分布改变的影响。</p><h3 id="缺点-1">缺点</h3><p>在类别不平衡的背景下，负例的数目众多致使FPR的增长不明显，ROC曲线的横轴采用FPR，根据<spanclass="math inline">\(FPR=\frac{FP}{N}=\frac{FP}{FP+TN}\)</span>，当负例N的数量远超正例P时，FP的大幅增长只能换来FPR的微小改变。结果是虽然大量负例被错判成正例，在ROC曲线上却无法直观地看出来。</p><h3 id="实现-2">实现</h3><ol type="1"><li><p><code>roc_curve</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fpr, tpr, thresholds = sklearn.metrics.roc_curve(y_true, y_score)<br>pyplot.plot(fpr, tpr)<br></code></pre></td></tr></table></figure><p><ahref="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_curve.html">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_curve.html</a></p></li><li><p><code>roc_auc_score</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">auc_score = sklearn.metrics.roc_auc_score(y_true, y_score)<br></code></pre></td></tr></table></figure><p><ahref="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html">https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html</a></p></li></ol><h2 id="参考资料">参考资料</h2><ol type="1"><li>https://machinelearningmastery.com/how-to-score-probability-predictions-in-python/</li><li>https://zhuanlan.zhihu.com/p/616190701</li><li>https://zhuanlan.zhihu.com/p/352271971</li><li>https://zhuanlan.zhihu.com/p/34655990</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概率评分方法&quot;&gt;概率评分方法&lt;/h1&gt;
&lt;p&gt;一般来说，&lt;strong&gt;评估预测概率准确性&lt;/strong&gt;的方法被称为评分规则或评分函数。下面将介绍三种评分方法，可用于评估&lt;strong&gt;分类预测建模&lt;/strong&gt;问题的预测概率。&lt;/p&gt;
&lt;h2 id=&quot;l</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://yinan.fun/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LR的预测概率值转分数</title>
    <link href="https://yinan.fun/LR%E7%9A%84%E9%A2%84%E6%B5%8B%E6%A6%82%E7%8E%87%E5%80%BC%E8%BD%AC%E5%88%86%E6%95%B0"/>
    <id>https://yinan.fun/LR%E7%9A%84%E9%A2%84%E6%B5%8B%E6%A6%82%E7%8E%87%E5%80%BC%E8%BD%AC%E5%88%86%E6%95%B0</id>
    <published>2023-08-05T08:01:39.000Z</published>
    <updated>2023-08-06T07:26:46.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lr的预测概率值转分数">LR的预测概率值转分数</h1><p>背景：在互联网金融中，一般用LR模型来预测一个借贷用户的好坏，但是LR模型得到的结果是逾期的概率值，如何仅仅给出预测概率值，人一般很难判断这个概率值代表的用户质量好坏，但是如果能够给出分数就比较理解了。而我们一般要把逾期概率转为分数来供公司进行决策，那么如何将逾期概率转化为用户质量的得分，例如0-100呢？</p><h2 id="评分卡的分数转化">评分卡的分数转化</h2><p>逻辑回归（LogisticRegression）是一种因变量与事件发生的概率之间的一种映射关系。其中的<strong>p/(1-p)</strong>，称为<strong>odds</strong>，即<strong>事件成功的概率</strong>除以<strong>事件失败的概率</strong>。<span class="math display">\[odds=\frac{p}{1-p}\]</span> 对几率取对数得到<strong>对数几率</strong>(logodds，亦称logit)： <span class="math display">\[log\frac{p}{1-p}=\omega^Tx+b\]</span></p><blockquote><p><span class="math display">\[y=\frac{1}{1+e^{-(w^{\rm{T}}x+b)}}\]</span></p><p><span class="math display">\[\ln \frac{y}{1-y}=w^{\rm{T}}x+b\]</span></p></blockquote><p><span class="math display">\[Score=A+B\times\ln(odds)\]</span></p><p>设定当每增加1倍时，增加的分数PDO（point of doubleodds），即比率翻番的倍数 <span class="math display">\[Score+PDO=A+B\times\ln(2odds)\]</span> 通过Score、odds、PDO可求解A和B。 <span class="math display">\[B = PDO/ln(2)\]</span> <span class="math display">\[A = Score-PDO*ln(odds)/ln(2)\]</span></p><p>评分卡不使用概率转换分数，而是用线性部分转换成分数，这样做的好处是，每一个特征<spanclass="math inline">\(x\)</span>的分数和就是总分，而如果用概率转分，则单个特征增加s分，总分并不增加s分。<span class="math display">\[\begin{align}Score&amp;=A+B\times(\omega_0+\omega_1x_1+\cdots+\omega_nx_x)\\&amp;=(A+B\omega_0)+B\omega_1x_1+\cdots+B\omega_nx_x\end{align}\]</span> <spanclass="math inline">\((A+B\omega_0)\)</span>是基础分数，<spanclass="math inline">\(B\omega_1x_1,\cdots,B\omega_nx_x\)</span>是每个变量对应分配的分数，求和得到总分数。</p><p>如果之前步骤中每个变量都有进行分箱操作，就把每个变量对应的分数，分别乘以变量中每个分箱的WOE，得到每个分箱的评分结果。</p><blockquote><p>WOE（Weight ofEvidence）即证据权重，可以将logistic回归模型转化为标准评分卡格式，WOE是对原始自变量的一种编码形式，要对一个变量进行WOE编码，需要首先把这个变量进行分组处理（也叫离散化、分箱）。WOE=ln(坏样本占比/好样本占比)<span class="math display">\[WOE_i=\ln(\frac{Bad_{X=X_i}/Bad_{tatol}}{Good_{X=X_i}/Good_{tatol}})\]</span></p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/202308051603736.png"alt="评分卡" /><figcaption aria-hidden="true">评分卡</figcaption></figure><p>以上步骤都完成后，假如新产生一个新样本，我们只需将此用户每个变量对应到各分箱中得到其对应的WOE值，再根据上面的公式计算出这个样本在每个变量下的分数。最后将所有变量对应的分数相加，即为最终评分结果。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li>https://blog.csdn.net/sscc_learning/article/details/78591210</li><li>https://www.ngui.cc/el/3600135.html?action=onClick</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lr的预测概率值转分数&quot;&gt;LR的预测概率值转分数&lt;/h1&gt;
&lt;p&gt;背景：在互联网金融中，一般用LR模型来预测一个借贷用户的好坏，但是LR模型得到的结果是逾期的概率值，如何仅仅给出预测概率值，人一般很难判断这个概率值代表的用户质量好坏，但是如果能够给出分数就比较理解</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://yinan.fun/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>图像质量评价指标</title>
    <link href="https://yinan.fun/%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"/>
    <id>https://yinan.fun/%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87</id>
    <published>2023-07-23T06:47:55.000Z</published>
    <updated>2023-07-30T03:34:21.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像质量评价指标">图像质量评价指标</h1><p>图像质量评价指标的最常见分类是通过参考图像的可用性，即全参考（full-reference,FR）、减少参考（reduced-reference, RR）和无参考（no-reference,NR）质量度量。FR度量计算失真图像和参考图像之间的相似性，当参考图像的部分信息可用时应用RR度量，而NR度量利用图像统计来评估图像质量，因为参考图像的信息完全不可用。</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230724182132014.png"alt="Representative FR and RR IQA methods" /><figcaption aria-hidden="true">Representative FR and RR IQAmethods</figcaption></figure><h2 id="psnr-peak-signal-to-noise-ratio-峰值信噪比">1. PSNR (PeakSignal-to-Noise Ratio) 峰值信噪比</h2><p>给定一个大小为<span class="math inline">\(m\timesn\)</span>的干净图像和噪声图像，<strong>均方误差(MSE)</strong>定义为：</p><p><span class="math display">\[MSE=\frac{1}{mn}\sum_{i=0}^{m-1}\sum_{i=0}^{n-1}[I(i,j)-K(i,j)]^2\]</span> 然后<strong>PSNR(dB) </strong> 就定义为：</p><p><span class="math display">\[PSNR=10\times log_{10}(\frac{MAX_I^2}{MSE})\]</span></p><p>其中<spanclass="math inline">\(MAX_I^2\)</span>为图片可能的最大像素值。如果每个像素都由8 位二进制来表示，那么就为255。通常，如果像素值由B位二进制来表示，那么<spanclass="math inline">\(MAX_I^2=2^B-1\)</span>。</p><p>一般地，针对 uint8 数据，最大像素值为255,；针对浮点型数据，最大像素值为 1。</p><p>上面是针对灰度图像的计算方法，如果是彩色图像，通常有三种方法来计算。</p><ul><li>分别计算 RGB 三个通道的 PSNR，然后取平均值。</li><li>计算 RGB 三通道的 MSE ，然后再除以 3 。</li><li>将图片转化为 YCbCr 格式，然后只计算 Y 分量也就是亮度分量的PSNR。</li></ul><p>其中，第二和第三种方法比较常见。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># method 1</span><br>diff = im1 - im2<br>mse = np.mean(np.square(diff))<br>psnr = <span class="hljs-number">10</span> * np.log10(<span class="hljs-number">255</span> * <span class="hljs-number">255</span> / mse)<br><br><span class="hljs-comment"># method 2</span><br><span class="hljs-keyword">from</span> skimage.metrics <span class="hljs-keyword">import</span> structural_similarity <span class="hljs-keyword">as</span> ssim<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment">#转为灰度图像</span><br>img1 = Image.<span class="hljs-built_in">open</span>(img1_path).convert(<span class="hljs-string">&#x27;L&#x27;</span>)<br>img2 = Image.<span class="hljs-built_in">open</span>(img2_path).convert(<span class="hljs-string">&#x27;L&#x27;</span>)<br>img2 = img2.resize(img1.size)<br>image_true, image_test = np.array(img1), np.array(img2)<br>psnr = skimage.metrics.peak_signal_noise_ratio(image_true, image_test, *, data_range=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><ahref="https://scikit-image.org/docs/dev/api/skimage.metrics.html#skimage.metrics.peak_signal_noise_ratio">https://scikit-image.org/docs/dev/api/skimage.metrics.html#skimage.metrics.peak_signal_noise_ratio</a></p><ul><li><p>参数：</p><p><code>image_true</code>:ndarray。Ground-truth图像，与im_test形状相同</p><p><code>image_test</code>: ndarray。测试图像</p><p><code>data_range</code>: int,optional。输入图像的数据范围(可能值的最小值和最大值之间的距离)。默认情况下，这是根据图像数据类型估计的</p></li><li><p>返回值</p><p><code>psnr</code>: float。PSNR值度量</p></li></ul><p>针对超光谱图像，我们需要针对不同波段分别计算PSNR，然后取平均值，这个指标称为 MPSNR。</p><p>PSNR等图像保真度测量方法虽然被广泛采用，但却无法很好地反映视觉质量。为了进一步接近人类视觉系统（humanvisual system, HVS）的质量评估，人们引入了结构相似性指数测量（Structuralsimilarity index measure, SSIM），利用其对结构信息变化的敏感性。</p><h2 id="ssim-structural-similarity-结构相似性">2. SSIM (StructuralSIMilarity) 结构相似性</h2><p>SSIM公式基于样本x和y之间的三个比较衡量：亮度 (luminance)、对比度(contrast) 和结构 (structure)。</p><p><span class="math display">\[l(x,y)=\frac{2\mu_x\mu_y+c_1}{\mu_x^2+\mu_y^2+c_1}\\c(x,y)=\frac{2\sigma_x\sigma_y+c_2}{\sigma_x^2+\sigma_y^2+c_2}\\s(x,y)=\frac{2\sigma_{xy}+c_3}{\sigma_x\sigma_y+c_3}\\\]</span></p><p>一般取<span class="math inline">\(c_3=c_2/2\)</span>。</p><ul><li><span class="math inline">\(\mu_x\)</span>为x均值，<spanclass="math inline">\(\sigma_x\)</span>为x方差，<spanclass="math inline">\(\sigma_{xy}\)</span>为x和y的协方差</li><li><span class="math inline">\(c_1=(k_1L)^2\)</span>,<spanclass="math inline">\(c_2=(k_2L)^2\)</span>为两个常数，避免除零</li><li>L为像素值的范围，<span class="math inline">\(L=2^B-1\)</span></li><li><span class="math inline">\(k_1=0.01,k_2=0.03\)</span>为默认值</li></ul><p>那么</p><p><span class="math display">\[SSIM(x,y)=[l(x,y)^\alpha\times c(x,y)^\beta\times s(x,y)^\gamma]\]</span> <spanclass="math inline">\(\alpha,\beta,\gamma\)</span>分别代表了不同特征在SSIM衡量中的占比，当都为1时，有：<span class="math display">\[SSIM(x,y)=\frac{(2\mu_x\mu_y+c_1)(2\sigma_x\sigma_y+c_2)}{(\mu_x^2+\mu_y^2+c_1)(\sigma_x^2+\sigma_y^2+c_2)}\]</span></p><p>每次计算的时候都从图片上取一个<span class="math inline">\(N\timesN\)</span>的窗口，然后不断滑动窗口进行计算，最后取平均值作为全局的SSIM。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">skimage.metrics.structural_similarity(im1, im2, *, win_size=<span class="hljs-literal">None</span>, gradient=<span class="hljs-literal">False</span>, data_range=<span class="hljs-literal">None</span>, <br>                                      channel_axis=<span class="hljs-literal">None</span>, gaussian_weights=<span class="hljs-literal">False</span>, full=<span class="hljs-literal">False</span>, **kwargs)<br></code></pre></td></tr></table></figure><p><ahref="https://scikit-image.org/docs/dev/api/skimage.metrics.html#skimage.metrics.structural_similarity">https://scikit-image.org/docs/dev/api/skimage.metrics.html#skimage.metrics.structural_similarity</a></p><ul><li><p>参数：</p><p><code>im1</code>, <code>im2</code>:ndarray。两个图片，任何具有相同形状的维度。</p><p><code>win_size</code>: int or None,optional。用来比对的滑动窗口的变长。必须是奇数。如果</p><p><code>gradient</code>: bool,optional。如果为True，也会返回相对于im2的梯度</p><p><code>data_range</code>: float,optional。输入图像的数据范围（最大和最小值之间可能的距离）使用默认，这会从图像数据类型中估计</p><p><code>channel_axis</code>: int or None,optional。如果为None，图像被假定为灰度图（单通道），否则，使用该参数索引轴的数组对应的通道</p><p><code>gaussian_weights</code>: bool,optional。如果为True，则每个patch的均值和方差由宽度σ=1.5的归一化高斯核进行空间加权。</p><p><code>full</code>: bool,optional。如果为True，也返回完整的结构相似度图像</p></li><li><p>返回值</p><p><code>mssim</code>: float。图像上的平均结构相似度指数</p><p><code>grad</code>:ndarray。im1和im2之间的结构相似度梯度。这只在梯度设置为True时返回</p><p><code>S</code>:ndarray。完整的SSIM映像。这只在full设置为True时返回</p></li></ul><p>针对超光谱图像，我们需要针对不同波段分别计算SSIM，然后取平均值，这个指标称为 MSSIM。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图像质量评价指标&quot;&gt;图像质量评价指标&lt;/h1&gt;
&lt;p&gt;图像质量评价指标的最常见分类是通过参考图像的可用性，即全参考（full-reference,
FR）、减少参考（reduced-reference, RR）和无参考（no-reference,
NR）质量</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="评价指标" scheme="https://yinan.fun/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>了解Llama</title>
    <link href="https://yinan.fun/%E4%BA%86%E8%A7%A3Llama"/>
    <id>https://yinan.fun/%E4%BA%86%E8%A7%A3Llama</id>
    <published>2023-07-23T04:32:17.000Z</published>
    <updated>2023-07-30T03:33:14.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解llama">了解Llama</h1><p>官网：<ahref="https://ai.meta.com/llama/">https://ai.meta.com/llama/</a></p><p>文章：<ahref="https://ai.meta.com/research/publications/llama-2-open-foundation-and-fine-tuned-chat-models/">https://ai.meta.com/research/publications/llama-2-open-foundation-and-fine-tuned-chat-models/</a></p><h2 id="介绍">介绍</h2><p>This release includes model weights and starting code for pretrainedand fine-tuned Llama language models — ranging from 7B to 70Bparameters(7B, 13B, 70B).</p><p>Llama 2 pretrained models are trained on 2 trillion tokens, and havedouble the context length than Llama 1. Its fine-tuned models have beentrained on over 1 million human annotations.</p><p><strong>Auto-regressive transformers</strong> are<strong>pretrained</strong> on an extensive corpus of self-superviseddata, followed by <strong>alignment</strong> with human preferences viatechniques such as Reinforcement Learning with Human Feedback(RLHF).</p><blockquote><p>Auto-regression is a time series model that <strong>uses observationsfrom previous time steps as input</strong> to a regression equation topredict the value at the next time step</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230723111842222.png"alt="AT VS. NAT" /><figcaption aria-hidden="true">AT VS. NAT</figcaption></figure><p>Llama2模型训练包括：预训练，有监督微调，RLHF。</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230721150225425.png"alt="Training of Llama 2-Chat" /><figcaption aria-hidden="true">Training of Llama 2-Chat</figcaption></figure><p>The training methodology is simple, but high computationalrequirements.</p><h2 id="训练">训练</h2><h3 id="预训练数据">预训练数据</h3><ul><li><p>训练语料库包括来自公开来源的新数据组合，其中不包括来自 Meta产品或服务的数据。</p></li><li><p>剔除某些已知包含大量个人隐私信息的网站的数据。</p></li><li><p>在 2万亿个tokem的数据上进行了训练，很好地权衡性能与成本。</p></li><li><p>对最真实的数据源进行上采样，以增加知识和减少错误。</p></li></ul><h3 id="训练细节">训练细节</h3><p>We adopt most of the <strong>pretraining setting and modelarchitecture from Llama 1</strong>. We use the <strong>standardtransformer architecture</strong> (Vaswani et al., 2017), applypre-normalization using <strong>RMSNorm</strong> (Zhang and Sennrich,2019), use the <strong>SwiGLU</strong> activation function (Shazeer,2020), and rotary positional embeddings (RoPE, Su et al. 2022). Theprimary architectural differences from Llama 1 include increased<strong>context length</strong> and <strong>grouped-queryattention</strong> (GQA).</p><blockquote><p>LayerNorm是对特征张量按照某一维度或某几个维度进行0均值，1方差的归一化。RMSNorm是对LayerNorm的一个改进，没有做re-center操作（移除了其中的均值项）。RMSNorm也是一种标准化方法，但与 LayerNorm不同，它不是使用整个样本的均值和方差，而是使用平方根的均值来归一化，这样做可以降低噪声的影响。</p></blockquote><blockquote><p>旋转式位置编码（RoPE）最早是一种能够将相对位置信息依赖集成到self-attention中并提升transformer架构性能的位置编码方式。</p></blockquote><blockquote><p>GQA（Grouped-QueryAttention）是分组查询注意力，GQA将查询头分成G组，每个组共享一个Key 和Value 矩阵。GQA-G是指具有G组的grouped-queryattention。其中多个查询头关注相同的键和值头，以减少推理过程中 KV缓存的大小，并可以显著提高推理吞吐量。GQA-1具有单个组，因此具有单个Key和 Value，等效于MQA。而GQA-H具有与头数相等的组，等效于MHA。</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230723112453383.png"alt="Llama 2 family of models" /><figcaption aria-hidden="true">Llama 2 family of models</figcaption></figure><ul><li><p>Hyperparameters</p><p>We trained using the <strong>AdamW optimizer</strong> (Loshchilov andHutter, 2017), with β1 = 0.9, β2 = 0.95, eps = 10-5. We use a<strong>cosine learning rate schedule</strong>, with warmup of 2000steps, and decay final learning rate down to 10% of the peak learningrate. We use a weight decay of 0.1 and gradient clipping of1.0.</p></li></ul><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230723115454030.png"alt="Training Loss for Llama 2 models" /><figcaption aria-hidden="true">Training Loss for Llama 2models</figcaption></figure><ul><li><p>Tokenizer</p><p>We use the same tokenizer as Llama 1; it employs a <strong>bytepairencoding</strong> (BPE) algorithm (Sennrich et al., 2016) using theimplementation from SentencePiece (Kudo and Richardson, 2018). As withLlama 1, we split all numbers into individual digits and use bytes todecompose unknown UTF-8 characters. The total vocabulary size is 32ktokens.</p></li><li><p>Llama 2预训练模型评估</p><ul><li>和开源模型对比，Llama 2性能最好。</li></ul><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230723120200445.png"alt="Overall performance on grouped academic benchmarks compared to open-source base models" /><figcaption aria-hidden="true">Overall performance on grouped academicbenchmarks compared to open-source base models</figcaption></figure><ul><li>和闭源模型对比，Llama 2有很大的性能差距。</li></ul><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230723120239606.png"alt="Comparison to closed-source models" /><figcaption aria-hidden="true">Comparison to closed-sourcemodels</figcaption></figure></li></ul><h2 id="微调">微调</h2><p>Llama 2-Chat是数月研究和反复应用对齐（alignment）技术的成果，包括指令调整（instructiontuning）和 RLHF，需要大量的计算和注释资源。</p><h3 id="supervised-fine-tuning-sft">Supervised Fine-Tuning (SFT)</h3><ul><li><p>Getting Started</p><p>To bootstrap, we started the SFT stage with <strong>publiclyavailable instruction tuning data</strong> (Chung et al., 2022), asutilized previously in Touvron et al. (2023).</p></li><li><p>Quality Is All You Need</p><p>By setting aside millions of examples from third-party datasets andusing <strong>fewer but higher-quality examples</strong> from our ownvendor-based annotation efforts, our results notably improved.</p></li></ul><p>For the fine-tuning process, each sample consists of a prompt and ananswer. To ensure the model sequence length is properly filled, we<strong>concatenate all the prompts and answers</strong> from thetraining set. A special token is utilized to separate the prompt andanswer segments. We utilize an autoregressive objective and zero-out theloss on tokens from the user prompt, so as a result, we backpropagateonly on answer tokens. Finally, we fine-tune the model for 2 epochs.</p><h3 id="reinforcement-learning-with-human-feedback-rlhf">ReinforcementLearning with Human Feedback (RLHF)</h3><p>RLHF is a model training procedure that is applied to a fine-tunedlanguage model to <strong>further align model behavior with humanpreferences and instruction following</strong>. We collect data thatrepresents empirically sampled human preferences, whereby humanannotators select which of two model outputs they prefer. This humanfeedback is subsequently used to <strong>train a reward model</strong>,which learns patterns in the preferences of the human annotators and canthen automate preference decisions.</p><ul><li><h4 id="human-preference-data-collection">Human Preference DataCollection</h4><p>Our annotation procedure proceeds as follows. We ask annotators tofirst <strong>write a prompt</strong>, then choose between two sampledmodel responses, based on provided criteria. In order to<strong>maximize the diversity</strong>, the two responses to a givenprompt are sampled from two different model variants, and varying thetemperature hyper-parameter. In addition to giving participants a forcedchoice, we also ask annotators to <strong>label the degree</strong> towhich they prefer their chosen response over the alternative: eithertheir choice is significantly better, better, slightly better, ornegligibly better/ unsure.</p><p>For our collection of preference annotations, we focus on<strong>helpfulness and safety</strong>.</p><p>Llama 2-Chat improvement also <strong>shifted the model’s datadistribution</strong>. Since reward model accuracy can quickly degradeif not exposed to this new sample distribution, i.e., fromhyper-specialization (Scialom et al., 2020b), it is important before anew Llama 2-Chat tuning iteration to <strong>gather new preferencedata</strong> using the latest Llama 2-Chat iterations. This step helpskeep the reward model on-distribution and maintain an accurate rewardfor the latest model.</p></li><li><h4 id="reward-modeling">Reward Modeling</h4><p>The reward model takes a model response and its corresponding prompt(including contexts from previous turns) as inputs and outputs a scalarscore to indicate the quality (e.g., helpfulness and safety) of themodel generation.</p><p>Helpfulness and safety sometimes trade off (Bai et al., 2022a), whichcan make it challenging for a single reward model to perform well onboth. To address this, we train <strong>two separate rewardmodels</strong>, one optimized for helpfulness (referred to asHelpfulness RM) and another for safety (Safety RM).</p><p><strong>Training Objectives</strong> <span class="math display">\[\mathcal{L}_{ranking}=-log(\sigma(r_{\theta}(x,y_c)-r_{\theta}(x,y_r)-m(r)))\]</span> where <span class="math inline">\(r_{\theta}(x,y)\)</span> isthe scalar score output for prompt <spanclass="math inline">\(x\)</span> and completion <spanclass="math inline">\(y\)</span> with model weights <spanclass="math inline">\(\theta\)</span>. <spanclass="math inline">\(y_c\)</span> is the preferred response thatannotators choose and <span class="math inline">\(y_r\)</span> is therejected counterpart. Margin <span class="math inline">\(m(r)\)</span>is a discrete function of the preference rating. Naturally, we use alarge margin for pairs with distinct responses, and a smaller one forthose with similar responses.</p></li><li><h4 id="iterative-fine-tuning">Iterative Fine-Tuning</h4><p>Two main algorithms</p><ul><li><p>Proximal Policy Optimization (PPO) (Schulman et al., 2017), thestandard in RLHF literature.</p><blockquote><p>近端策略优化（proximal policyoptimization，PPO），通过重要性采样把同策略换成异策略。</p><p><ahref="https://datawhalechina.github.io/easy-rl/#/chapter5/chapter5">https://datawhalechina.github.io/easy-rl/#/chapter5/chapter5</a></p></blockquote></li><li><p>Rejection Sampling fine-tuning. We <strong>sample Koutputs</strong> from the model and <strong>select the bestcandidate</strong> with our reward. Here, we go one step further, anduse the selected outputs for a <strong>gradient update</strong>. Foreach prompt, the sample obtaining the highest reward score is consideredthe new <strong>gold standard</strong>. Similar to Scialom et al.(2020a), we then fine-tune our model on the new set of ranked samples,reinforcing the reward.</p><blockquote><p>挑出分数最高的response作为training target，做supervised fine-tuning(SFT)。</p></blockquote><p>We perform rejection <strong>sampling only</strong> with our<strong>largest 70B Llama 2-Chat</strong>. All smaller models are<strong>fine-tuned on rejection sampled data from the largermodel</strong>, thus distilling the large-model capabilities into thesmaller ones.</p></li></ul></li></ul><h2 id="使用llama">使用Llama</h2><p><ahref="https://huggingface.co/docs/transformers/main/en/model_doc/llama">https://huggingface.co/docs/transformers/main/en/model_doc/llama</a></p><p><ahref="https://huggingface.co/docs/transformers/main/en/model_doc/llama2">https://huggingface.co/docs/transformers/main/en/model_doc/llama2</a></p><ul><li>下载模型参数。Weights for the LLaMA models can be obtained from byfilling out <ahref="https://docs.google.com/forms/d/e/1FAIpQLSfqNECQnMkycAp2jP4Z9TFX0cGR4uf7b_fBxjY_OjhJILlKGA/viewform?usp=send_form">thisform</a></li><li>转换为Hugging Face格式。After downloading the weights, they willneed to be converted to the Hugging Face Transformers format using the<ahref="https://github.com/huggingface/transformers/blob/main/src/transformers/models/llama/convert_llama_weights_to_hf.py">conversionscript</a>. The script can be called with the following (example)command:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python src/transformers/models/llama/convert_llama_weights_to_hf.py \<br>    --input_dir /path/to/downloaded/llama/weights --model_size 7B --output_dir /output/path<br></code></pre></td></tr></table></figure><ul><li>加载模型和tokenizer。After conversion, the model and tokenizer canbe loaded via:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> LlamaForCausalLM, LlamaTokenizer<br><br>tokenizer = LlamaTokenizer.from_pretrained(<span class="hljs-string">&quot;/output/path&quot;</span>)<br>model = LlamaForCausalLM.from_pretrained(<span class="hljs-string">&quot;/output/path&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解llama&quot;&gt;了解Llama&lt;/h1&gt;
&lt;p&gt;官网：&lt;a
href=&quot;https://ai.meta.com/llama/&quot;&gt;https://ai.meta.com/llama/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章：&lt;a
href=&quot;https://ai.me</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="语言模型" scheme="https://yinan.fun/tags/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>调试运行华驼模型</title>
    <link href="https://yinan.fun/%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E5%8D%8E%E9%A9%BC%E6%A8%A1%E5%9E%8B"/>
    <id>https://yinan.fun/%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E5%8D%8E%E9%A9%BC%E6%A8%A1%E5%9E%8B</id>
    <published>2023-07-21T04:42:30.000Z</published>
    <updated>2023-07-30T03:39:43.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试运行华驼模型">调试运行华驼模型</h1><p>论文地址：<ahref="https://arxiv.org/abs/2304.06975">https://arxiv.org/abs/2304.06975</a></p><p>项目地址：<ahref="https://github.com/SCIR-HI/Huatuo-Llama-Med-Chinese">https://github.com/SCIR-HI/Huatuo-Llama-Med-Chinese</a></p><ul><li><p>运行<code>infer.py</code>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">UnicodeDecodeError: <span class="hljs-string">&#x27;gbk&#x27;</span> codec can<span class="hljs-string">&#x27;t decode byte 0xae in position 84: illegal </span><br><span class="hljs-string">multibyte sequence</span><br></code></pre></td></tr></table></figure><p>修改<code>prompter.py</code>21行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br></code></pre></td></tr></table></figure><p>修改<code>infer.py</code>18行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(instruct_dir, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br></code></pre></td></tr></table></figure></li><li><p>运行<code>infer.py</code>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">HFValidationError: Repo <span class="hljs-built_in">id</span> must use alphanumeric chars or <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span> <br>and <span class="hljs-string">&#x27;..&#x27;</span> are forbidden, <span class="hljs-string">&#x27;-&#x27;</span> and <span class="hljs-string">&#x27;.&#x27;</span> cannot start or end the name, max length is<br>96: <span class="hljs-string">&#x27;&#x27;</span>.<br></code></pre></td></tr></table></figure><p>尝试下载模型参数，调用本地模型参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">base_model: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;./llama-7b-hf&quot;</span>,<br></code></pre></td></tr></table></figure></li><li><p>运行<code>infer.py</code>报错（使用CPU）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">The current device_map had weights offloaded to the disk. Please provide an offload_folder <span class="hljs-keyword">for</span> them. Alternatively, make sure you have safetensors installed <span class="hljs-keyword">if</span> the model you are using offers the weights <span class="hljs-keyword">in</span> this format<br></code></pre></td></tr></table></figure><p><ahref="https://github.com/huggingface/transformers/issues/18698">https://github.com/huggingface/transformers/issues/18698</a>这里说</p><p>There is no support for using the CPU as a main device in Accelerateyet. If you want to use the model on CPU, just don't specific<code>device_map="auto"</code>.</p><p>参数去掉<code>device_map="auto"</code></p></li><li><p>修改<code>infer.py</code>13行（使用CPU）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">device = <span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>运行<code>infer.py</code>报错（使用CPU）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">RuntimeError: <span class="hljs-string">&quot;addmm_impl_cpu_&quot;</span> not implemented <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Half&#x27;</span><br></code></pre></td></tr></table></figure><p>CPU无法使用 <code>fp16</code>（半精度），把<code>model.half()</code>，改成<code>model.float()</code></p></li><li><p>未微调模型结果（CPU跑了两个小时）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">###infering###</span><br><span class="hljs-comment">###instruction###</span><br>小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。<br><span class="hljs-comment">###golden output###</span><br>小张可能患有心肌炎，建议进行心电图和心脏超声等检查来确定诊断。治疗方案包括使用泼尼松、生脉饮和三磷酸腺苷等药物，同时建议适当控制体温，保持良好的营养状况。<br><span class="hljs-comment">###model output###</span><br>小张感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。 问题：小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。 问题：小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。 问题：小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减��<br></code></pre></td></tr></table></figure></li><li><p>微调模型结果（基于医学知识库对<code>LLaMA</code>进行指令微调的<code>LoRA</code>权重文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">using lora ./lora-llama-med<br><span class="hljs-comment">###infering###</span><br><span class="hljs-comment">###instruction###</span><br>小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。<br><span class="hljs-comment">###golden output###</span><br>小张可能患有心肌炎，建议进行心电图和心脏超声等检查来确定诊断。治疗方案包括使用泼尼松、生脉饮和三磷酸腺苷等药物，同时建议适当控制体温，保持良好的营养状况。<br><span class="hljs-comment">###model output###</span><br>小张可能患有心肌炎，需要进行心脏超声、心电图检查等辅助检查以确定诊断。治疗方案包括使用抗生素、抗坏血酸等药物进行治疗，同时建议加强营养，避免过度劳累。&lt;/s&gt;<br><span class="hljs-comment">###infering###</span><br><span class="hljs-comment">###instruction###</span><br>小刘最近咳嗽流鼻涕，应该采取哪些治疗方案？<br><span class="hljs-comment">###golden output###</span><br>中药对咳嗽的治疗具有多靶点优势，如连花清咳片等，其融汇了东汉张仲景《伤寒论》中宣肺泄热、止咳平喘的麻杏石甘汤；明代叶文龄《医学统旨》中的清金化痰汤，其中清半夏燥湿化痰，桑白皮止咳平喘，苦杏仁镇咳平喘，桔梗宣肺利咽、镇咳排痰，前胡降气化痰；宫廷要药大黄通腑泄肺，让引起咳嗽的肺部热毒通过排便排出体外；再配合具有清热解毒作用的山银花、黄芩、连翘等，可以说是集中了清宣肺热、止咳化痰、促进排痰、利咽平喘的一批药物，发挥多靶点治疗作用。<br><span class="hljs-comment">###model output###</span><br>对于小刘的咳嗽流鼻涕，治疗方案可以考虑使用链霉素、氨苄西林、硫唑嘌呤等药物。&lt;/s&gt;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调试运行华驼模型&quot;&gt;调试运行华驼模型&lt;/h1&gt;
&lt;p&gt;论文地址：&lt;a
href=&quot;https://arxiv.org/abs/2304.06975&quot;&gt;https://arxiv.org/abs/2304.06975&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a
h</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="语言模型" scheme="https://yinan.fun/tags/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Idea快捷键</title>
    <link href="https://yinan.fun/Idea%E5%BF%AB%E6%8D%B7%E9%94%AE"/>
    <id>https://yinan.fun/Idea%E5%BF%AB%E6%8D%B7%E9%94%AE</id>
    <published>2023-07-18T15:19:40.000Z</published>
    <updated>2023-07-25T10:04:40.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="idea开发常用快捷键">IDEA开发常用快捷键</h1><table><thead><tr class="header"><th>快捷键组合</th><th>实现效果</th></tr></thead><tbody><tr class="odd"><td>psvm + Tab键 / main + Tab键</td><td>public static void main(String[] args)</td></tr><tr class="even"><td>sout + Tab键</td><td>System.out.println()</td></tr><tr class="odd"><td>Ctrl + X</td><td>删除当前行</td></tr><tr class="even"><td>Ctrl +D</td><td>复制当前行</td></tr><tr class="odd"><td>Alt+Insert(或右键Generate)</td><td>生成代码(如get,set方法,构造函数等)</td></tr><tr class="even"><td>Ctrl+Alt+T</td><td>生成try catch （或者 Alt+enter选择）</td></tr><tr class="odd"><td>CTRL+ALT+T</td><td>把选中的代码放在 TRY{} IF{} ELSE{} 里</td></tr><tr class="even"><td>Ctr+shift+U</td><td>实现大小写之间的转化</td></tr><tr class="odd"><td>ALT+回车</td><td>导入包,自动修正</td></tr><tr class="even"><td>CTRL+ALT+L</td><td>格式化代码</td></tr><tr class="odd"><td>CTRL+ALT+I</td><td>自动缩进</td></tr><tr class="even"><td>CTRL+E</td><td>最近更改的代码</td></tr><tr class="odd"><td>fori</td><td>生成for (int i = 0; i &lt; ; i++) {}</td></tr><tr class="even"><td>Alt + &lt;–左右–&gt;键</td><td>实现窗口左右更换（多窗口）</td></tr><tr class="odd"><td>Ctrl + 鼠标点击</td><td>快速找到成员变量的出处</td></tr><tr class="even"><td>Shift+F6</td><td>重构/重命名 (包、类、方法、变量、甚至注释等)</td></tr><tr class="odd"><td>CTRL+Q</td><td>查看当前方法的声明</td></tr><tr class="even"><td>Ctrl+Alt+V</td><td>自动创建变量（new 对象();之后选择按快捷键）</td></tr><tr class="odd"><td>Ctrl+O</td><td>重写方法</td></tr><tr class="even"><td>Ctrl+I</td><td>实现方法</td></tr><tr class="odd"><td>ALT+/</td><td>代码提示</td></tr><tr class="even"><td>Ctrl+Shift+R</td><td>在当前项目中替换指定内容</td></tr><tr class="odd"><td>Ctrl+E</td><td>最近编辑的文件列表</td></tr><tr class="even"><td>Ctrl+P</td><td>显示方法参数信息</td></tr><tr class="odd"><td>Ctrl+Shift+Insert</td><td>查看历史复制记录，idea可以保留历史复制的 100 条记录</td></tr></tbody></table><h2 id="控制台语句-system.out-相关">控制台语句 System.out 相关：</h2><table><thead><tr class="header"><th>生成控制台的相关快捷键</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>sout + Tab键</td><td>生成System.out.println();，输出到控制台语句并换行。</td></tr><tr class="even"><td>souf + Tab键</td><td>生成System.out.printf("");,输出一个格式化字符串到控制台。</td></tr><tr class="odd"><td>soutm + Tab键</td><td>生成System.out.println("类名.方法名");，输出当前 类和方法名到控制台。</td></tr><tr class="even"><td>soutp + Tab键</td><td>生成System.out.println(所有方法参数名+值);，输出当前方法的参数名和值 到控制台。</td></tr></tbody></table><h2 id="查找">查找</h2><table><thead><tr class="header"><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr class="odd"><td>Ctrl + F</td><td>在当前文件进行文本查找</td></tr><tr class="even"><td>Ctrl + R</td><td>在当前文件进行文本替换</td></tr><tr class="odd"><td>Shift + Ctrl + F</td><td>在项目进行文本查找</td></tr><tr class="even"><td>Shift + Ctrl + R</td><td>在项目进行文本替换</td></tr><tr class="odd"><td>Shift + Shift</td><td>快速搜索</td></tr><tr class="even"><td>Ctrl + N</td><td>查找class</td></tr><tr class="odd"><td>Ctrl + Shift + N</td><td>查找文件</td></tr><tr class="even"><td>Ctrl + Shift + Alt + N</td><td>查找symbol（查找某个方法名）</td></tr></tbody></table><h2 id="跳转切换">跳转切换</h2><table><thead><tr class="header"><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr class="odd"><td>Ctrl + E</td><td>最近文件</td></tr><tr class="even"><td>Ctrl + Tab</td><td>切换文件</td></tr><tr class="odd"><td>Ctrl + Alt + ←/→</td><td>跳转历史光标所在处</td></tr><tr class="even"><td>Alt + ←/→ 方向键</td><td>切换子tab</td></tr><tr class="odd"><td>Ctrl + G</td><td>go to（跳转指定行号）</td></tr></tbody></table><h2 id="编码相关">编码相关</h2><table><thead><tr class="header"><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr class="odd"><td>Ctrl + W</td><td>快速选中</td></tr><tr class="even"><td>(Shift + Ctrl) + Alt + J</td><td>快速选中同文本</td></tr><tr class="odd"><td>Ctrl + C/Ctrl + X/Ctrl + D</td><td>快速复制或剪切</td></tr><tr class="even"><td>多行选中 Tab / Shift + Tab</td><td>tab</td></tr><tr class="odd"><td>Ctrl + Y</td><td>删除整行</td></tr><tr class="even"><td>滚轮点击变量/方法/类</td><td>快速进入变量/方法/类的定义处</td></tr><tr class="odd"><td>Shift + 点击Tab</td><td>快速关闭tab</td></tr><tr class="even"><td>Ctrl + Z 、Ctrl + Shift + Z</td><td>后悔药，撤销/取消撤销</td></tr><tr class="odd"><td>Ctrl + Shift + enter</td><td>自动收尾，代码自动补全</td></tr><tr class="even"><td>Alt + enter</td><td>IntelliJ IDEA根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td></tr><tr class="odd"><td>Alt + ↑/↓</td><td>方法快速跳转</td></tr><tr class="even"><td>F2</td><td>跳转到下一个高亮错误 或 警告位置</td></tr><tr class="odd"><td>Alt + Insert</td><td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString()等</td></tr><tr class="even"><td>Ctrl + Shift + L</td><td>格式化代码</td></tr><tr class="odd"><td>Shift + F6</td><td>快速修改方法名、变量名、文件名、类名等</td></tr><tr class="even"><td>Ctrl + F6</td><td>快速修改方法签名</td></tr></tbody></table><h2 id="代码阅读相关">代码阅读相关</h2><table><thead><tr class="header"><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr class="odd"><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr class="even"><td>Ctrl + Shift + i</td><td>就可以在当前类里再弹出一个窗口出来</td></tr><tr class="odd"><td>Alt + F7</td><td>可以列出变量在哪些地方被使用了</td></tr><tr class="even"><td>光标在子类接口名，Ctrl + u</td><td>跳到父类接口</td></tr><tr class="odd"><td>Alt + F1 + 1， esc</td><td></td></tr><tr class="even"><td>(Shift) + Ctrl + +/-</td><td>代码块折叠</td></tr><tr class="odd"><td>Ctrl + Shift + ←/→</td><td>移动窗口分割线</td></tr><tr class="even"><td>Ctrl + (Alt) + B</td><td>跳转方法定义/实现</td></tr><tr class="odd"><td>Ctrl + H</td><td>类的层级关系</td></tr><tr class="even"><td>Ctrl + F12</td><td>Show Members 类成员快速显示</td></tr></tbody></table><h2 id="版本管理相关">版本管理相关</h2><table><thead><tr class="header"><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr class="odd"><td>Ctrl + D</td><td>Show Diff</td></tr><tr class="even"><td>(Shift) + F7</td><td>（上）下一处修改</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;idea开发常用快捷键&quot;&gt;IDEA开发常用快捷键&lt;/h1&gt;
&lt;table&gt;

&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;快捷键组合&lt;/th&gt;
&lt;th&gt;实现效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="快捷键" scheme="https://yinan.fun/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
    <category term="Idea" scheme="https://yinan.fun/tags/Idea/"/>
    
  </entry>
  
  <entry>
    <title>Domain-Adversarial Training of Neural Networks（DaNN）实现</title>
    <link href="https://yinan.fun/Domain-Adversarial-Training-of-Neural-Networks%EF%BC%88DaNN%EF%BC%89%E5%AE%9E%E7%8E%B0"/>
    <id>https://yinan.fun/Domain-Adversarial-Training-of-Neural-Networks%EF%BC%88DaNN%EF%BC%89%E5%AE%9E%E7%8E%B0</id>
    <published>2023-07-12T09:25:21.000Z</published>
    <updated>2023-07-25T10:07:53.612Z</updated>
    
    <content type="html"><![CDATA[<h1id="domain-adversarial-training-of-neural-networksdann实现">Domain-AdversarialTraining of Neural Networks（DaNN）实现</h1><h2 id="总体介绍">总体介绍</h2><p>在传统的机器学习中，我们经常需要<strong>大量带标签的数据</strong>进行训练，并且需要保证<strong>训练集和测试集中的数据分布相似</strong>。在一些问题中，如果训练集和测试集的数据具有不同的分布，训练后的分类器在测试集上就没有好的表现。</p><p><strong>域适应</strong>（DomainAdaption）是<strong>迁移学习</strong>中一个重要的分支，目的是把具有不同分布的<strong>源域</strong>(SourceDomain) 和<strong>目标域</strong> (Target Domain)中的数据，映射到同一个特征空间，寻找某一种度量准则，使其在这个空间上的“距离”尽可能近。然后，我们在源域(带标签) 上训练好的分类器，就可以直接用于目标域数据的分类。</p><p><strong>DaNN</strong>是一种域适应学习方法，它采用了GAN的思想。为了使模型在目标集上也能有好的表现，它的目的是使模型特征提取器在源域和目标域提取的特征具有相同的分布。</p><p>DANN结构主要包含3个部分：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713155252247.png"alt="image-20230713155252247" /><figcaption aria-hidden="true">image-20230713155252247</figcaption></figure><ul><li><strong>特征提取器</strong> （feature extractor） -图示绿色部分，用来<strong>将数据映射到特定的特征空间</strong>，使标签预测器能够分辨出来自源域数据的类别的同时，域判别器无法区分数据来自哪个域。</li><li>标签预测器 （label predictor） -图示蓝色部分，对来自源域的数据进行分类，尽可能分出<strong>正确的标签</strong>。</li><li><strong>域判别器</strong>（domain classifier）-图示红色部分，对特征空间的数据进行分类，尽可能分出<strong>数据来自哪个域</strong>。</li></ul><p>对抗迁移网络的总损失由两部分构成：网络的训练损失（标签预测器损失）和域判别损失。</p><p>我们通过最小化目标函数来更新标签预测器的参数，最大化目标函数来更新域判别器的参数。</p><p>相关论文：https://arxiv.org/abs/1505.07818</p><h2 id="代码实现">代码实现</h2><p>特征提取器实现，VGG网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FeatureExtractor</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(FeatureExtractor, self).__init__()<br><br>        self.conv = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">128</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">128</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">256</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">256</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.conv(x).squeeze()<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>标签预测器实现，由线性层组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LabelPredictor</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(LabelPredictor, self).__init__()<br><br>        self.layer = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, h</span>):<br>        c = self.layer(h)<br>        <span class="hljs-keyword">return</span> c<br></code></pre></td></tr></table></figure><p>域判别器实现，由线性层组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DomainClassifier</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(DomainClassifier, self).__init__()<br><br>        self.layer = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">1</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, h</span>):<br>        y = self.layer(h)<br>        <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></table></figure><p>损失函数选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">class_criterion = nn.CrossEntropyLoss()<br>domain_criterion = nn.BCEWithLogitsLoss()<br></code></pre></td></tr></table></figure><p>训练过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, ((source_data, source_label), (target_data, _)) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(source_dataloader, target_dataloader)):<br>    source_data = source_data.to(device)<br>    source_label = source_label.to(device)<br>    target_data = target_data.to(device)<br>    mixed_data = torch.cat([source_data, target_data], dim=<span class="hljs-number">0</span>)<br>    domain_label = torch.zeros([source_data.shape[<span class="hljs-number">0</span>] + target_data.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>]).to(device)<br>    domain_label[:source_data.shape[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 1. 先训练domain classifier</span><br>    feature = feature_extractor(mixed_data)<br>    domain_logits = domain_classifier(feature.detach())<br>    loss = domain_criterion(domain_logits, domain_label)<br>    domain_classifier_losses.append(loss.item())<br>    running_D_loss += loss.item()<br>    loss.backward()<br>    optimizer_D.step()<br><br>    <span class="hljs-comment"># 2. 训练 feature extractor 和 label classifier</span><br>    class_logits = label_predictor(feature[:source_data.shape[<span class="hljs-number">0</span>]])<br>    domain_logits = domain_classifier(feature)<br>    loss = class_criterion(class_logits, source_label) - lamb * domain_criterion(domain_logits, domain_label)<br>    total_losses.append(loss.item())<br>    running_F_loss += loss.item()<br>    loss.backward()<br>    optimizer_F.step()<br>    optimizer_C.step()<br><br>    optimizer_D.zero_grad()<br>    optimizer_F.zero_grad()<br>    optimizer_C.zero_grad()<br></code></pre></td></tr></table></figure><h2 id="结果">结果</h2><p>训练损失上下波动，是特征提取器和域判别器在不断对抗。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713171352103.png"alt="image-20230713171352103" /><figcaption aria-hidden="true">image-20230713171352103</figcaption></figure><p>训练10、100、200个epoch后，特征提取器提取的特征分布按类别和source/target展示。可以看到，随着训练的过程，特征越来越能区分不同的类，source和targetdomain的分布越来越一致。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713171446520.png"alt="image-20230713171446520" /><figcaption aria-hidden="true">image-20230713171446520</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713171459818.png"alt="image-20230713171459818" /><figcaption aria-hidden="true">image-20230713171459818</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713171519185.png"alt="image-20230713171519185" /><figcaption aria-hidden="true">image-20230713171519185</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1
id=&quot;domain-adversarial-training-of-neural-networksdann实现&quot;&gt;Domain-Adversarial
Training of Neural Networks（DaNN）实现&lt;/h1&gt;
&lt;h2 id=&quot;总体介绍&quot;&gt;总</summary>
      
    
    
    
    <category term="项目" scheme="https://yinan.fun/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="机器学习" scheme="https://yinan.fun/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://yinan.fun/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>了解ChatGPT</title>
    <link href="https://yinan.fun/%E4%BA%86%E8%A7%A3ChatGPT"/>
    <id>https://yinan.fun/%E4%BA%86%E8%A7%A3ChatGPT</id>
    <published>2023-07-11T02:21:41.000Z</published>
    <updated>2023-07-25T10:06:05.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解chatgpt">了解ChatGPT</h1><h2 id="chatgpt的功能">1. ChatGPT的功能</h2><p>如果我们向ChatGPT询问ChatGPT的<strong>功能</strong>：</p><p>ChatGPT具有以下功能：</p><ol type="1"><li>回答问题：ChatGPT可以<strong>回答各种问题</strong>，包括常见知识、事实、定义、历史事件等。</li><li>提供解释：ChatGPT可以<strong>解释复杂的概念</strong>、原理、术语等，并帮助你更好地理解。</li><li>提供建议：ChatGPT可以<strong>提供关于各种主题的建议</strong>，例如旅行目的地、电影推荐、食谱等。</li><li>进行对话：ChatGPT可以<strong>进行对话</strong>，你可以与它交流，分享观点、提问问题或寻求帮助。</li><li>写作辅助：如果你需要<strong>写作文章</strong>、创作故事或撰写邮件，ChatGPT可以<strong>提供灵感</strong>、提供写作建议和进行文本生成。</li></ol><p>请注意，尽管ChatGPT具备广泛的知识和语言理解能力，但它仍然是一个模型，<strong>可能会出现错误或提供不准确的答案</strong>。在使用时，请谨慎评估和验证信息的准确性。（ChatGPT生成）</p><p>另外，从OpenAI的官网我们可以了解到，ChatGPT<strong>以对话的方式进行交互</strong>，对话形式使ChatGPT能够回答后续问题、承认错误、质疑不正确的前提并拒绝不适当的请求。</p><p>OpenAI的官网也列出了ChatGPT的<strong>缺点</strong>，例如有时会回答看似有道理但是是错误或没意义的回答，对提问的方式敏感，模型过于冗长，在用户询问模糊的问题时猜测用户的想法。</p><h2 id="chatgpt的原理">2. ChatGPT的原理</h2><p>如果我们向ChatGPT询问ChatGPT的<strong>原理</strong>：</p><p>ChatGPT的实现是基于<strong>深度学习</strong>和<strong>自监督学习</strong>的方法。下面将详细说明ChatGPT的实现过程：</p><ol type="1"><li>数据收集：为了<strong>预训练</strong>ChatGPT，大量的互联网<strong>文本数据</strong>被收集和准备。这些数据可以包括网页内容、书籍、维基百科、新闻文章等。这些文本数据被用来构建一个庞大的语料库，作为模型的训练数据。</li><li>构建Transformer模型：ChatGPT是基于<strong>Transformer</strong>模型构建的。Transformer模型是一种使用自注意力机制（self-attention）的序列到序列模型，它能够处理长距离依赖关系并捕捉上下文信息。Transformer模型由多个编码器和解码器层组成，每个层都包含多头注意力机制和前馈神经网络。</li><li>预训练：在<strong>预训练</strong>阶段，ChatGPT使用大规模的语料库进行训练。模型通过<strong>自监督学习</strong>的方式进行预训练，即在没有人工标注的情况下进行训练。预训练的目标是<strong>预测下一个单词或标记</strong>。通过这种方式，模型能够学习到语言的统计规律、语义关系和上下文信息。预训练使用了大量的计算资源和并行计算，通常需要花费数天甚至数周的时间。</li><li>微调：在预训练之后，ChatGPT需要进行<strong>微调</strong>以<strong>适应特定的任务</strong>。对于对话式交互，微调阶段通常使用<strong>对话数据</strong>进行训练。对话数据包括用户的问题和模型的回答。通过在这些对话数据上进行微调，模型能够更好地理解和生成对话，并提供准确的回答。</li><li>模型优化和部署：在微调之后，ChatGPT需要进行<strong>模型优化和部署</strong>，以提高性能和效率。这包括模型的压缩、加速和优化，以便在实际应用中能够快速响应用户的请求。</li></ol><p>需要注意的是，ChatGPT的实现过程非常复杂，并需要大量的计算资源和数据。OpenAI团队在实现ChatGPT时投入了大量的研究和工程工作，以使其具备强大的语言理解和生成能力。（ChatGPT生成）</p><p>OpenAI的官网简要说明了ChatGPT的方法。模型训练使用了<strong>ReinforcementLearning from Human Feedback</strong>(RLHF)，即以强化学习方式依据人类反馈优化语言模型。开始使用有监督的微调训练初始模型。然后收集comparisondata为强化学习训练一个奖励模型（reward model）。最后使用Proximal PolicyOptimization强化学习算法微调模型。</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/ChatGPT_Diagram.svg"alt="Chatgpt Diagram" /><figcaption aria-hidden="true">Chatgpt Diagram</figcaption></figure><p>OpenAI的官网说：We trained this model using Reinforcement Learningfrom Human Feedback (RLHF), using the same methods as <ahref="https://openai.com/blog/instruction-following/"><strong>InstructGPT</strong></a>,but with slight differences in the data collection setup.因此，要了解更多关于ChatGPT也可以阅读instructGPT的论文：https://arxiv.org/abs/2203.02155。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解chatgpt&quot;&gt;了解ChatGPT&lt;/h1&gt;
&lt;h2 id=&quot;chatgpt的功能&quot;&gt;1. ChatGPT的功能&lt;/h2&gt;
&lt;p&gt;如果我们向ChatGPT询问ChatGPT的&lt;strong&gt;功能&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;ChatGPT具有以下</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="ChatGPT" scheme="https://yinan.fun/tags/ChatGPT/"/>
    
    <category term="语言模型" scheme="https://yinan.fun/tags/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>爱楼表情包网站</title>
    <link href="https://yinan.fun/%E7%88%B1%E6%A5%BC%E8%A1%A8%E6%83%85%E5%8C%85%E7%BD%91%E7%AB%99"/>
    <id>https://yinan.fun/%E7%88%B1%E6%A5%BC%E8%A1%A8%E6%83%85%E5%8C%85%E7%BD%91%E7%AB%99</id>
    <published>2023-06-03T02:21:41.000Z</published>
    <updated>2023-07-30T03:38:01.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爱楼-表情包网站">爱楼-表情包网站</h1><h2 id="页面展示">页面展示</h2><ul><li>主页</li></ul><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230717161539797.png"alt="image-20230717161539797" /><figcaption aria-hidden="true">image-20230717161539797</figcaption></figure><ul><li>管理员页面</li></ul><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230717161629434.png"alt="image-20230717161629434" /><figcaption aria-hidden="true">image-20230717161629434</figcaption></figure><ul><li>后端文档</li></ul><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230717161823777.png"alt="image-20230717161823777" /><figcaption aria-hidden="true">image-20230717161823777</figcaption></figure><h2 id="需求分析">需求分析</h2><ol type="1"><li>用户根据名字和标签搜索表情包</li><li>用户上传表情包</li><li>管理员管理表情包</li></ol><h2 id="技术栈">技术栈</h2><h3 id="前端">前端</h3><ul><li>框架：Vue 3</li><li>组件库：Ant Design Vue</li><li>请求：Axios</li><li>路由：Vue Router</li><li>文件下载：FileSaver</li></ul><h3 id="后端">后端</h3><ul><li>Java 8</li><li>开发框架：SpringBoot 2.x</li><li>数据访问：MyBatis + MyBatis Plus</li><li>缓存：Redis</li><li>项目管理：Maven</li><li>接口文档：Swagger + Knife4j</li></ul><h3 id="存储">存储</h3><ul><li>数据库：MySQL</li><li>对象存储：七牛云 COS</li></ul><h3 id="部署">部署</h3><ul><li>前端：Nginx + Docker</li><li>后端：Docker容器</li></ul><h2 id="特性">特性</h2><ol type="1"><li>使用 Redis缓存首页高频访问的表情包列表，将接口响应时长从120毫秒缩短至20毫秒。<br /></li><li>选用 MyBatis + MyBatis-Plus进行数据访问层开发，复用大多数通用方法，并且通过继承定制了自己的通用操作模板，大幅提升了项目开发效率。<br /></li><li>为了明确接口的返回，自定义统一的错误码，并封装了全局异常处理器，从而规范了异常返回、屏蔽了项目冗余的报错细节。<br /></li><li>自主编写 Dockerfile，并通过容器部署，提高部署上线效率。<br /></li><li>使用 Knife4j + Swagger自动生成后端接口文档，避免了人工编写维护文档的麻烦。<br /></li><li>前端使用 Vant UI 组件库，并封装了全局通用的 Layout组件，使主页、搜索页、管理页布局一致、并减少重复代码。</li></ol><h2 id="软件设计">软件设计</h2><h3 id="数据库设计">数据库设计</h3><p><strong>数据库名：</strong> ilou</p><table><thead><tr class="header"><th style="text-align: left;">表名</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><a href="#emoji">emoji</a></td><td style="text-align: left;">表情</td></tr><tr class="even"><td style="text-align: left;"><a href="#tag">tag</a></td><td style="text-align: left;">标签</td></tr></tbody></table><p><strong>表名：</strong> <a id="tag">emoji</a></p><p><strong>说明：</strong> 表情</p><p><strong>数据列：</strong></p><table><thead><tr class="header"><th style="text-align: center;">序号</th><th style="text-align: left;">名称</th><th style="text-align: center;">数据类型</th><th style="text-align: center;">长度</th><th style="text-align: center;">小数位</th><th style="text-align: center;">允许空值</th><th style="text-align: center;">主键</th><th style="text-align: center;">默认值</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: left;">id</td><td style="text-align: center;">int</td><td style="text-align: center;">10</td><td style="text-align: center;">0</td><td style="text-align: center;">N</td><td style="text-align: center;">Y</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: left;">url</td><td style="text-align: center;">varchar</td><td style="text-align: center;">4096</td><td style="text-align: center;">0</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: left;">name</td><td style="text-align: center;">varchar</td><td style="text-align: center;">512</td><td style="text-align: center;">0</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: left;">userId</td><td style="text-align: center;">int</td><td style="text-align: center;">10</td><td style="text-align: center;">0</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">0</td><td style="text-align: center;">上传用户id</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: left;">tags</td><td style="text-align: center;">varchar</td><td style="text-align: center;">1024</td><td style="text-align: center;">0</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;"></td><td style="text-align: center;">标签数组json</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: left;">reviewStatus</td><td style="text-align: center;">int</td><td style="text-align: center;">10</td><td style="text-align: center;">0</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td><td style="text-align: center;">0</td><td style="text-align: center;">0-待审核,1-通过,2-拒绝</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: left;">createTime</td><td style="text-align: center;">datetime</td><td style="text-align: center;">19</td><td style="text-align: center;">0</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">CURRENT_TIMESTAMP</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: left;">isDelete</td><td style="text-align: center;">tinyint</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td><td style="text-align: center;">0</td><td style="text-align: center;">是否删除0-未删除1-已删除</td></tr><tr class="odd"><td style="text-align: center;">9</td><td style="text-align: left;">updateTime</td><td style="text-align: center;">datetime</td><td style="text-align: center;">19</td><td style="text-align: center;">0</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">CURRENT_TIMESTAMP</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>表名：</strong> <a id="tag">tag</a></p><p><strong>说明：</strong> 标签</p><p><strong>数据列：</strong></p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">序号</th><th style="text-align: left;">名称</th><th style="text-align: center;">数据类型</th><th style="text-align: center;">长度</th><th style="text-align: center;">小数位</th><th style="text-align: center;">允许空值</th><th style="text-align: center;">主键</th><th style="text-align: center;">默认值</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: left;">id</td><td style="text-align: center;">int</td><td style="text-align: center;">10</td><td style="text-align: center;">0</td><td style="text-align: center;">N</td><td style="text-align: center;">Y</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: left;">name</td><td style="text-align: center;">varchar</td><td style="text-align: center;">512</td><td style="text-align: center;">0</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td><td style="text-align: center;"></td><td style="text-align: center;">标签名</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: left;">createTime</td><td style="text-align: center;">datetime</td><td style="text-align: center;">19</td><td style="text-align: center;">0</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">CURRENT_TIMESTAMP</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: left;">isDelete</td><td style="text-align: center;">tinyint</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td><td style="text-align: center;">0</td><td style="text-align: center;">是否删除0-未删除1-已删除</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: left;">updateTime</td><td style="text-align: center;">datetime</td><td style="text-align: center;">19</td><td style="text-align: center;">0</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">CURRENT_TIMESTAMP</td><td style="text-align: center;"></td></tr></tbody></table><h3 id="后端接口设计">后端接口设计</h3><p><ahref="ilou-api.yinan.fun/api/doc.html">ilou-api.yinan.fun/api/doc.html</a></p><h3 id="通用返回对象">通用返回对象</h3><p>给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">SUCCESS(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;ok&quot;</span>),<br>PARAMS_ERROR(<span class="hljs-number">40000</span>, <span class="hljs-string">&quot;请求参数错误&quot;</span>),<br>NOT_LOGIN_ERROR(<span class="hljs-number">40100</span>, <span class="hljs-string">&quot;未登录&quot;</span>),<br>NO_AUTH_ERROR(<span class="hljs-number">40101</span>, <span class="hljs-string">&quot;无权限&quot;</span>),<br>NOT_FOUND_ERROR(<span class="hljs-number">40400</span>, <span class="hljs-string">&quot;请求数据不存在&quot;</span>),<br>FORBIDDEN_ERROR(<span class="hljs-number">40300</span>, <span class="hljs-string">&quot;禁止访问&quot;</span>),<br>SYSTEM_ERROR(<span class="hljs-number">50000</span>, <span class="hljs-string">&quot;系统内部异常&quot;</span>),<br>OPERATION_ERROR(<span class="hljs-number">50001</span>, <span class="hljs-string">&quot;操作失败&quot;</span>),<br>FILE_UPLOAD_ERROR(<span class="hljs-number">50010</span>, <span class="hljs-string">&quot;文件上传错误&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="全局异常处理器">全局异常处理器</h3><ol type="1"><li><p>定义业务异常类</p><ol type="1"><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 / 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器（利用 SpringAOP，在调用方法前后进行额外的处理）</p></li></ol><h3 id="源码">源码</h3><p><ahref="https://github.com/wyn04/ilou">https://github.com/wyn04/ilou</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;爱楼-表情包网站&quot;&gt;爱楼-表情包网站&lt;/h1&gt;
&lt;h2 id=&quot;页面展示&quot;&gt;页面展示&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;主页&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://jsdelivr.codeqihan.com/gh/w</summary>
      
    
    
    
    <category term="项目" scheme="https://yinan.fun/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="JAVA" scheme="https://yinan.fun/tags/JAVA/"/>
    
    <category term="SpringBoot" scheme="https://yinan.fun/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>PyInstaller python 打包工具使用</title>
    <link href="https://yinan.fun/PyInstaller-python-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8"/>
    <id>https://yinan.fun/PyInstaller-python-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8</id>
    <published>2023-05-22T08:43:42.000Z</published>
    <updated>2023-07-25T10:04:57.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pyinstaller-python-打包工具使用">PyInstaller python打包工具使用</h1><h2 id="参数">参数</h2><table><thead><tr class="header"><th>参数名</th><th>描述</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>-D</td><td>生成one-folder的程序（默认）</td><td>生成结果是一个目录，各种第三方依赖、资源和exe同时存储在该目录</td></tr><tr class="even"><td>-F</td><td>生成one-file的程序</td><td>生成结果是一个exe文件，所有的第三方依赖、资源和代码均被打包进该exe内</td></tr><tr class="odd"><td>–add-data</td><td>打包额外资源</td><td>用法：pyinstaller main.py--add-data=src;dest。windows以;分割，macOS/linux以:分割</td></tr><tr class="even"><td>-c</td><td>显示命令行窗口</td><td>与-w相反，默认含有此参数</td></tr><tr class="odd"><td>-w</td><td>不显示命令行窗口</td><td>编写GUI程序时使用此参数有用。</td></tr><tr class="even"><td>-i</td><td>为main.exe指定图标</td><td>用法：pyinstaller -i beauty.ico main.py</td></tr></tbody></table><p>具体参数看：https://blog.csdn.net/weixin_39000819/article/details/80942423</p><h2 id="打包图片等资源">打包图片等资源</h2><p>即使使用了<code>–add-data</code>参数也大概率还是会出现图片文件没有找到的情况。</p><p>因为当app运行的时候，会先<strong>把资源解压到一个系统的临时目录</strong>，包括打包进去的img文件等。但是，此时的代码并不能直接通过 “img/texture.png”这样的相对路径来得到文件,应该是因为本身程序就不在这里，所以自然引用不到。</p><p>这时需要用到 sys 的一个半私有的属性<code>sys._MEIPASS</code>，根据官方的说明，它是 pyinstaller运行时创建的<strong>临时目录的绝对路径</strong>。需要在程序运行时判断当前是不是有这个属性，如果有的话，使用生成临时目录下图片的绝对路径，如果没有的话，那就直接返回当前程序的绝对路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_resource_path</span>(<span class="hljs-params">relative_path</span>):<br>    <span class="hljs-comment"># 资源路径拼接当前运行时临时目录路径</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(sys, <span class="hljs-string">&#x27;_MEIPASS&#x27;</span>):<br>        <span class="hljs-keyword">return</span> os.path.join(sys._MEIPASS, relative_path)<br>    <span class="hljs-keyword">return</span> os.path.join(os.path.abspath(<span class="hljs-string">&quot;.&quot;</span>), relative_path)<br></code></pre></td></tr></table></figure><p>每次用到图片资源地址的时候都调用<code>get_resource_path</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">texture_filename = get_resource_path(<span class="hljs-string">&quot;img/texture.png&quot;</span>)<br>texture = cv2.imread(texture_filename)<br></code></pre></td></tr></table></figure><p>之后就可以使用下面的命令（windows要将<code>:</code>改成<code>;</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pyinstaller --add-data img:img -wF img2sketch.py</span><br></code></pre></td></tr></table></figure><p>在<code>disk</code>目录下生成可执行文件</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230522162328233.png"alt="image-20230522162328233" /><figcaption aria-hidden="true">image-20230522162328233</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pyinstaller-python-打包工具使用&quot;&gt;PyInstaller python
打包工具使用&lt;/h1&gt;
&lt;h2 id=&quot;参数&quot;&gt;参数&lt;/h2&gt;
&lt;table&gt;

&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;参数名&lt;/t</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://yinan.fun/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Python" scheme="https://yinan.fun/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令大全</title>
    <link href="https://yinan.fun/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8"/>
    <id>https://yinan.fun/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8</id>
    <published>2023-05-02T15:37:59.000Z</published>
    <updated>2023-07-25T10:03:46.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker常用命令大全">Docker常用命令大全</h1><h2 id="帮助类启动命令">1、帮助类启动命令</h2><ul><li>启动docker： systemctl start docker</li><li>停止docker： systemctl stop docker</li><li>重启docker： systemctl restart docker</li><li>查看docker状态： systemctl status docker</li><li>开机启动： systemctl enable docker</li><li>查看docker概要信息： docker info</li><li>查看docker总体帮助文档： docker --help</li><li>查看docker命令帮助文档： docker 具体命令 --help</li></ul><h2 id="镜像命令">2、镜像命令</h2><h3 id="列出本地主机上的镜像">1、列出本地主机上的镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/7000-20230417102853412.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这里插入图片描述</p><p>各个选项说明:</p><ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签版本号</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul><blockquote><p>同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用REPOSITORY:TAG 来定义不同的镜像。</p><p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker将默认使用 ubuntu:latest 镜像</p></blockquote><p>OPTIONS说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a :列出本地所有的镜像（含历史映像层）<br><br>docker images -a<br><br><br><br>-q :只显示镜像ID。<br><br>docker images -q<br></code></pre></td></tr></table></figure><h3 id="搜索镜像">2、搜索镜像</h3><p>官方搜索网址：https://hub.docker.com/</p><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search [OPTIONS] 镜像名字<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker search mysql<br><br>NAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br><br>mysql                            MySQL is a widely used, open-source relation…   12378     [OK]       <br><br>mariadb                          MariaDB Server is a high performing open sou…   4762      [OK]       <br><br>mysql/mysql-server               Optimized MySQL Server Docker images. Create…   917                  [OK]<br><br>percona                          Percona Server is a fork of the MySQL relati…   572       [OK]       <br><br>phpmyadmin                       phpMyAdmin - A web interface for MySQL and M…   494       [OK]       <br><br>mysql/mysql-cluster              Experimental MySQL Cluster Docker images. Cr…   93                   <br><br>centos/mysql-57-centos7          MySQL 5.7 SQL database server                   92                   <br><br>bitnami/mysql                    Bitnami MySQL Docker Image                      68                   [OK]<br><br>ubuntu/mysql                     MySQL open source fast, stable, multi-thread…   29                   <br><br>circleci/mysql                   MySQL is a widely used, open-source relation…   25                   <br><br>mysql/mysql-router               MySQL Router provides transparent routing be…   23                   <br><br>centos/mysql-56-centos7          MySQL 5.6 SQL database server                   22                   <br><br>google/mysql                     MySQL server for Google Compute Engine          21                   [OK]<br><br>vmware/harbor-db                 Mysql container for Harbor                      10                   <br><br>mysqlboy/docker-mydumper         docker-mydumper containerizes MySQL logical …   3                    <br><br>mysqlboy/mydumper                mydumper for mysql logcial backups              3                    <br><br>bitnami/mysqld-exporter                                                          2                    <br><br>ibmcom/mysql-s390x               Docker image for mysql-s390x                    2                    <br><br>mysql/mysql-operator             MySQL Operator for Kubernetes                   0                    <br><br>ibmcom/tidb-ppc64le              TiDB is a distributed NewSQL database compat…   0                    <br><br>mysqlboy/elasticsearch                                                           0                    <br><br>mysqleatmydata/mysql-eatmydata                                                   0                    <br><br>cimg/mysql                                                                       0                    <br><br>mysql/ndb-operator               MySQL NDB Operator for Kubernetes               0                    <br><br>mirantis/mysql  <br></code></pre></td></tr></table></figure><figure><img src="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/7000.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这里插入图片描述</p><h4 id="options说明">OPTIONS说明：</h4><ul><li>--limit : 只列出N个镜像，默认25个</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search --limit 5 redis<br></code></pre></td></tr></table></figure><h3 id="拉取下载镜像">3、拉取（下载）镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 某个XXX镜像名字<br></code></pre></td></tr></table></figure><ul><li>docker pull 某个XXX镜像名字:TAG</li><li>docker pull 镜像名字</li></ul><blockquote><p>没有TAG就是最新版</p><p>等价于：docker pull 镜像名字:latest</p></blockquote><h3 id="查看镜像">4、查看镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker system df 查看镜像/容器/数据卷所占的空间<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker system df<br><br>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br><br>Images          1         1         13.26kB   0B (0%)<br><br>Containers      1         0         0B        0B<br><br>Local Volumes   0         0         0B        0B<br><br>Build Cache     0         0         0B        0B<br><br>[root@docker ~]# <br></code></pre></td></tr></table></figure><h3 id="删除镜像">5、删除镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi 某个XXX镜像名字ID<br></code></pre></td></tr></table></figure><h4 id="删除单个">1、删除单个</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi  -f 镜像ID<br></code></pre></td></tr></table></figure><h4 id="删除多个">2、删除多个</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi -f 镜像名1:TAG 镜像名2:TAG <br></code></pre></td></tr></table></figure><h3 id="删除全部">3、删除全部</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi -f $(docker images -qa)<br></code></pre></td></tr></table></figure><h3id="面试题谈谈docker虚悬镜像是什么">6、面试题：谈谈docker虚悬镜像是什么？</h3><blockquote><p>仓库名、标签都是<none>的镜像，俗称虚悬镜像dangling image</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/7000-20230417102853439.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这里插入图片描述</p><h2 id="容器命令">3、容器命令</h2><blockquote><p>有镜像才能创建容器</p></blockquote><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/7000-20230417102853482.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>本次用centos进行演示</p><h3 id="新建启动命令">1、新建+启动命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p><p>--name="容器新名字" 为容器指定一个名称；</p><p>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</p><p>-i：以交互模式运行容器，通常与 -t 同时使用；</p><p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>也即启动交互式容器(前台有伪终端，等待交互)；</p><p>-P: 随机端口映射，大写P</p><p>-p: 指定端口映射，小写p</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/7000-20230417102853467.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这里插入图片描述</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/7000-20230417102853397.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这里插入图片描述</p><blockquote><p>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it centos /bin/bash <br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-i: 交互式操作。</p><p>-t: 终端。</p><p>centos : centos 镜像。</p><p>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式Shell，因此用的是 /bin/bash。</p><p>要退出终端，直接输入 exit:</p><h3 id="列出当前所有正在运行的容器">2、列出当前所有正在运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps [OPTIONS]<br></code></pre></td></tr></table></figure><blockquote><p>OPTIONS说明（常用）：</p><p>-a :列出当前所有正在运行的容器+历史上运行过的</p><p>-l :显示最近创建的容器。</p><p>-n：显示最近n个创建的容器。</p><p>-q :静默模式，只显示容器编号。</p></blockquote><h3 id="退出容器">3、退出容器</h3><h4 id="exec退出">1、<code>exec</code>退出</h4><blockquote><p>run进去容器，exit退出，容器停止</p></blockquote><h4 id="ctrlpq">2、<code>ctrl+p+q</code></h4><blockquote><p>run进去容器，ctrl+p+q退出，容器不停止</p></blockquote><h3 id="启动已停止运行的容器">4、启动已停止运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器ID或者容器名<br></code></pre></td></tr></table></figure><h3 id="重启容器">5、重启容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart 容器ID或者容器名<br></code></pre></td></tr></table></figure><h3 id="停止容器">6、停止容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop 容器ID或者容器名<br></code></pre></td></tr></table></figure><h3 id="强制停止容器">7、强制停止容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="删除已停止的容器">8、删除已停止的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器ID<br></code></pre></td></tr></table></figure><h4 id="一次性删除多个容器实例">一次性删除多个容器实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -f $(docker ps -a -q)<br><br><br><br>docker ps -a -q | xargs docker rm<br></code></pre></td></tr></table></figure><p><code>docker ps -a -q</code>：查询进行的容器ID</p><h2 id="实操">4、实操</h2><h3 id="启动守护式容器后台服务器">1、启动守护式容器(后台服务器)</h3><blockquote><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d指定容器的后台运行模式。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d 容器名<br></code></pre></td></tr></table></figure><p>#使用镜像centos:latest以后台模式启动一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d centos<br></code></pre></td></tr></table></figure><p>问题：然后docker ps -a 进行查看,会发现容器已经退出很重要的要说明的一点:Docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如servicenginxstart但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~</p><h4 id="案例演示">案例演示</h4><blockquote><p><ahref="https://cloud.tencent.com/product/crs?from=20065&amp;from_column=20065">redis</a>前后台启动演示case（下载一个Redis6.0.8镜像演示）</p></blockquote><ul><li>前台交互式启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it redis<br></code></pre></td></tr></table></figure><ul><li>后台守护式启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d redis<br></code></pre></td></tr></table></figure><p>PS：启动容器后，先查看容器是否启动正常，往往伴随着<code>docker ps</code></p><h3 id="查看容器日志">2、查看容器日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs 容器ID<br></code></pre></td></tr></table></figure><p>PS：容器ID可省略为前三位</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker ps <br><br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS      NAMES<br><br>94b526c73db2   redis     &quot;docker-entrypoint.s…&quot;   4 seconds ago   Up 3 seconds   6379/tcp   admiring\_poincare<br><br>[root@docker ~]# docker logs 94b<br><br>1:C 10 Apr 2022 09:50:03.396 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo<br><br>1:C 10 Apr 2022 09:50:03.396 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started<br><br>1:C 10 Apr 2022 09:50:03.396 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf<br><br>1:M 10 Apr 2022 09:50:03.397 \* monotonic clock: POSIX clock\_gettime<br><br>1:M 10 Apr 2022 09:50:03.398 \* Running mode=standalone, port=6379.<br><br>1:M 10 Apr 2022 09:50:03.399 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br><br>1:M 10 Apr 2022 09:50:03.399 # Server initialized<br><br>1:M 10 Apr 2022 09:50:03.399 # WARNING overcommit\_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit\_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit\_memory=1&#x27; for this to take effect.<br><br>1:M 10 Apr 2022 09:50:03.399 \* Ready to accept connections<br><br>[root@docker ~]# <br></code></pre></td></tr></table></figure><h3 id="查看容器内运行的进程">3、查看容器内运行的进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top 容器ID<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker top 94b<br><br>UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD<br><br>polkitd             35360               35341               0                   17:50               ?                   00:00:00            redis-server \*:6379<br></code></pre></td></tr></table></figure><h3 id="查看容器内部细节">4、查看容器内部细节</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 容器ID<br></code></pre></td></tr></table></figure><h3 id="进入容器内部">5、进入容器内部</h3><h4 id="使用exec进入容器">1、使用<code>exec</code>进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it 容器ID bashShell<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker exec -it 94b /bin/bash<br><br>root@94b526c73db2:/data# redis-c<br><br>redis-check-aof  redis-check-rdb  redis-cli        <br><br>root@94b526c73db2:/data# redis-cli <br><br>127.0.0.1:6379&gt; ping<br><br>PONG<br><br>127.0.0.1:6379&gt; set k1 v1<br><br>OK<br><br>127.0.0.1:6379&gt; get k1<br><br>&quot;v1&quot;<br><br>127.0.0.1:6379&gt; exit<br></code></pre></td></tr></table></figure><p>exec帮助命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker exec --help<br><br><br><br>Usage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br><br><br><br>Run a command in a running containe<br><br><br><br>Options:<br><br>  -d, --detach               Detached mode: run command in the background<br><br>      --detach-keys string   Override the key sequence for detaching a containe<br><br>  -e, --env list             Set environment variables<br><br>      --env-file list        Read in a file of environment variables<br><br>  -i, --interactive          Keep STDIN open even if not attached<br><br>      --privileged           Give extended privileges to the command<br><br>  -t, --tty                  Allocate a pseudo-TTY<br><br>  -u, --user string          Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])<br><br>  -w, --workdir string       Working directory inside the containe<br><br>[root@docker ~]# <br></code></pre></td></tr></table></figure><h4 id="使用attach进入容器">2、使用<code>attach</code>进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach 容器ID<br></code></pre></td></tr></table></figure><h4 id="两者的区别">3、两者的区别</h4><ul><li>attach直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会导致容器的停止。</li><li>exec是在容器中打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器的停止。</li></ul><p>PS：推荐大家使用<code>docker exec</code>命令，因为退出容器终端，不会导致容器的停止。</p><h2 id="从容器内拷贝文件到主机上">5、从容器内拷贝文件到主机上</h2><blockquote><p>把文件从容器内部复制到主机上</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp  容器ID:容器内路径 目的主机路径<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp 3065f084c80d:a.txt a.txt<br></code></pre></td></tr></table></figure><h2 id="导入和导出容器">6、导入和导出容器</h2><h3 id="导出容器">1、导出容器</h3><blockquote><p>export 导出容器的内容留作为一个tar归档文件对应import命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker export 容器ID &gt; 文件名.ta<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker /]# docker export 3065f084c80d &gt; centos.tar.gz<br><br>[root@docker /]# ll<br><br>总用量 233004<br><br>-rw-r--r--.   1 root root         0 4月  10 18:16 a.txt<br><br>lrwxrwxrwx.   1 root root         7 4月   9 15:59 bin -&gt; usr/bin<br><br>dr-xr-xr-x.   5 root root      4096 4月   9 16:06 boot<br><br>-rw-r--r--.   1 root root 238572032 4月  10 19:04 centos.tar.gz<br><br>drwxr-xr-x.  20 root root      3220 4月   9 16:29 dev<br><br>drwxr-xr-x.  86 root root      8192 4月  10 11:03 etc<br><br>drwxr-xr-x.   3 root root        22 4月   9 16:05 home<br><br>lrwxrwxrwx.   1 root root         7 4月   9 15:59 lib -&gt; usr/lib<br><br>lrwxrwxrwx.   1 root root         9 4月   9 15:59 lib64 -&gt; usr/lib64<br><br>drwxr-xr-x.   2 root root         6 4月  11 2018 media<br><br>drwxr-xr-x.   2 root root         6 4月  11 2018 mnt<br><br>drwxr-xr-x.   4 root root        34 4月   9 20:38 opt<br><br>dr-xr-xr-x. 124 root root         0 4月   9 16:29 proc<br><br>dr-xr-x---.   5 root root       176 4月   9 20:36 root<br><br>drwxr-xr-x.  31 root root       940 4月   9 21:01 run<br><br>lrwxrwxrwx.   1 root root         8 4月   9 15:59 sbin -&gt; usr/sbin<br><br>drwxr-xr-x.   2 root root         6 4月  11 2018 srv<br><br>dr-xr-xr-x.  13 root root         0 4月   9 16:29 sys<br><br>drwxrwxrwt.  13 root root      4096 4月  10 18:16 tmp<br><br>drwxr-xr-x.  13 root root       155 4月   9 15:59 us<br></code></pre></td></tr></table></figure><h3 id="导入容器">2、导入容器</h3><blockquote><p>import 从tar包中的内容创建一个新的文件系统再导入为镜像对应export</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker /]# cat centos.tar.gz | docker import - xiaobear/centos:8.8<br><br>sha256:12e7a58fc36a755fa63a82f78364291de7271c3ade90f2f5581cc50bc2416cb2<br><br>[root@docker /]# docker images<br><br>REPOSITORY        TAG       IMAGE ID       CREATED              SIZE<br><br>xiaobear/centos   8.8       12e7a58fc36a   About a minute ago   231MB<br><br>redis             latest    7614ae9453d1   3 months ago         113MB<br><br>hello-world       latest    feb5d9fea6a5   6 months ago         13.3kB<br><br>centos            latest    5d0da3dc9764   6 months ago         231MB<br><br>[root@docker /]# <br></code></pre></td></tr></table></figure><h2 id="常用命令汇总">7、常用命令汇总</h2><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/7000-20230417102853593.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><table><thead><tr class="header"><th>命令</th><th>英文</th><th>中文</th></tr></thead><tbody><tr class="odd"><td>attach</td><td>Attach to a running container</td><td>当前 shell 下 attach 连接指定运行镜像</td></tr><tr class="even"><td>build</td><td>Build an image from a Dockerfile</td><td>通过 Dockerfile 定制镜像</td></tr><tr class="odd"><td>commit</td><td>Create a new image from a container changes</td><td>提交当前容器为新的镜像</td></tr><tr class="even"><td>cp</td><td>Copy files/folders from the containers filesystem to the hostpath</td><td>容器中拷贝指定文件或者目录到宿主机中</td></tr><tr class="odd"><td>create</td><td>Create a new container</td><td>创建一个新的容器，同 run，但不启动容器</td></tr><tr class="even"><td>diff</td><td>Inspect changes on a container's filesystem</td><td>查看 docker 容器变化</td></tr><tr class="odd"><td>events</td><td>Get real time events from the server</td><td>从 docker 服务获取容器实时事件</td></tr><tr class="even"><td>exec</td><td>Run a command in an existing container</td><td>在已存在的容器上运行命令</td></tr><tr class="odd"><td>export</td><td>Stream the contents of a container as a tar archive</td><td>导出容器的内容流作为一个 tar 归档文件对应 import</td></tr><tr class="even"><td>images</td><td>List images</td><td>列出系统当前镜像</td></tr><tr class="odd"><td>import</td><td>Create a new filesystem image from the contents of a tarball</td><td>从tar包中的内容创建一个新的文件系统映像对应export</td></tr><tr class="even"><td>info</td><td>Display system-wide information</td><td>显示系统相关信息</td></tr><tr class="odd"><td>inspect</td><td>Return low-level information on a container</td><td>查看容器详细信息</td></tr><tr class="even"><td>kill</td><td>Kill a running container</td><td>kill 指定 docker 容器</td></tr><tr class="odd"><td>load</td><td>Load an image from a tar archive</td><td>从一个 tar 包中加载一个镜像对应 save</td></tr><tr class="even"><td>login</td><td>Register or Login to the docker registry server</td><td>注册或者登陆一个 docker 源服务器</td></tr><tr class="odd"><td>logout</td><td>Log out from a Docker registry server</td><td>从当前 Docker registry 退出</td></tr><tr class="even"><td>logs</td><td>Fetch the logs of a container</td><td>输出当前容器日志信息</td></tr><tr class="odd"><td>port</td><td>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</td><td>查看映射端口对应的容器内部源端口</td></tr><tr class="even"><td>pause</td><td>Pause all processes within a container</td><td>暂停容器</td></tr><tr class="odd"><td>ps</td><td>List containers</td><td>列出容器列表</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker常用命令大全&quot;&gt;Docker常用命令大全&lt;/h1&gt;
&lt;h2 id=&quot;帮助类启动命令&quot;&gt;1、帮助类启动命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;启动docker： systemctl start docker&lt;/li&gt;
&lt;li&gt;停止docker： sys</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://yinan.fun/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Docker" scheme="https://yinan.fun/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>2. 日志系统：一条SQL更新语句是如何执行的？</title>
    <link href="https://yinan.fun/2.%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"/>
    <id>https://yinan.fun/2.%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F</id>
    <published>2023-05-01T13:42:27.000Z</published>
    <updated>2023-07-25T10:02:53.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志系统一条sql更新语句是如何执行的">2.日志系统：一条SQL更新语句是如何执行的？</h2><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块：<strong>redolog（重做日志）和 binlog（归档日志）</strong>。</p><h3 id="redo-log">2.1 redo log</h3><p>如果<strong>每一次的更新操作都需要写进磁盘</strong>，然后磁盘也要找到对应的那条记录，然后再更新，整个过程<strong>IO成本、查找成本都很高</strong>。</p><p><strong>WAL</strong>的全称是Write-AheadLogging，它的关键点就是<strong>先写日志，再写磁盘</strong>。</p><p>当有一条记录需要<strong>更新</strong>的时候，InnoDB引擎就会<strong>先把记录写到redolog</strong>里面，并<strong>更新内存</strong>，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录<strong>更新到磁盘里面</strong>，而这个更新往往是在系统比较<strong>空闲</strong>的时候做。</p><p>InnoDB的redolog是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230508202933697.png"alt="image-20230508202933697" /><figcaption aria-hidden="true">image-20230508202933697</figcaption></figure><p><strong>writepos</strong>是<strong>当前记录的位置</strong>，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。<strong>checkpoint</strong>是<strong>当前要擦除的位置</strong>，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是redolog上还空着的部分，可以用来记录新的操作。如果writepos追上checkpoint，表示redolog这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><p>有了redolog，InnoDB就可以保证<strong>即使数据库发生异常重启，之前提交的记录都不会丢失</strong>，这个能力称为<strong>crash-safe</strong>。</p><h3 id="binlog">2.2 binlog</h3><p>redolog是InnoDB引擎特有的日志，而<strong>Server层</strong>也有自己的日志，称为binlog（归档日志）。</p><p>这两种日志有以下三点不同。</p><ol type="1"><li><p>redolog是<strong>InnoDB引擎特有</strong>的；binlog是<strong>MySQL的Server层实现</strong>的，所有引擎都可以使用。</p></li><li><p>redolog是<strong>物理日志</strong>，记录的是“在某个数据页上<strong>做了什么修改</strong>”；binlog是<strong>逻辑日志</strong>，记录的是这个<strong>语句的原始逻辑</strong>，比如“给ID=2这一行的c字段加1”。</p></li><li><p>redolog是<strong>循环写</strong>的，空间固定会用完；binlog是可以<strong>追加写入</strong>的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并<strong>不会覆盖</strong>以前的日志。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table T(ID int primary key, c int);<br>mysql&gt; update T set c=c+1 where ID=2;<br></code></pre></td></tr></table></figure><p>执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p><ol type="1"><li><p>执行器先<strong>找引擎取ID=2这一行</strong>。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p></li><li><p>执行器拿到引擎给的行数据，<strong>把这个值加上1</strong>，比如原来是N，现在就是N+1，得到新的一行数据，再<strong>调用引擎接口写入这行新数据</strong>。</p></li><li><p><strong>引擎</strong>将这行新数据<strong>更新到内存</strong>中，同时将这个更新操作<strong>记录到redolog</strong>里面，此时redolog处于<strong>prepare状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</p></li><li><p><strong>执行器</strong>生成这个操作的binlog，并把<strong>binlog写入磁盘</strong>。</p></li><li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redolog改成<strong>提交（commit）状态</strong>，更新完成。</p></li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/image-20230508202945483.png"alt="image-20230508202945483" /><figcaption aria-hidden="true">image-20230508202945483</figcaption></figure><p>将redolog的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。</p><h3 id="两阶段提交">2.3 两阶段提交</h3><p>为什么必须有“两阶段提交”呢？这是为了<strong>让两份日志之间的逻辑一致</strong>。</p><p>当需要数据库<strong>恢复到指定的某一秒</strong>时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li><p>首先，找到<strong>最近的一次全量备份</strong>，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</p></li><li><p>然后，从备份的时间点开始，<strong>将备份的binlog依次取出来</strong>，重放到中午误删表之前的那个时刻。</p></li></ul><p>由于redolog和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redolog再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><ol type="1"><li><strong>先写先 redo log后写后 binlog</strong>。假设在redolog写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redolog写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li><li><strong>先写先 binlog后写后 redolog</strong>。如果在binlog写完之后crash，由于redolog还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>简单说，redolog和binlog都可以用于表示事务的提交状态，而两阶段提交就是<strong>让这两个状态保持逻辑上的一致</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;日志系统一条sql更新语句是如何执行的&quot;&gt;2.
日志系统：一条SQL更新语句是如何执行的？&lt;/h2&gt;
&lt;p&gt;与查询流程不一样的是，更新流程还涉及两个重要的日志模块：&lt;strong&gt;redo
log（重做日志）和 binlog（归档日志）&lt;/strong&gt;。&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://yinan.fun/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据库" scheme="https://yinan.fun/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://yinan.fun/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>1. 基础架构：一条SQL查询语句是如何执行的？</title>
    <link href="https://yinan.fun/1.%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"/>
    <id>https://yinan.fun/1.%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F</id>
    <published>2023-05-01T13:18:38.000Z</published>
    <updated>2023-07-25T09:08:47.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础架构一条sql查询语句是如何执行的">1.基础架构：一条SQL查询语句是如何执行的？</h2><p>下面是<strong>MySQL的基本架构</strong>示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p><figure><imgsrc="https://jsdelivr.codeqihan.com/gh/wyn04/my-pic-bed/f6b1fbd6cbe8b2592a8d535221e7b51d-20230504093007977.png"alt="image-20230308152659467" /><figcaption aria-hidden="true">image-20230308152659467</figcaption></figure><p>MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分。</p><ol type="1"><li><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数<strong>核心服务功能</strong>，以及所有的<strong>内置函数</strong>（如日期、时间、数学和加密函数等），所有<strong>跨存储引擎的功能</strong>都在这一层实现，比如存储过程、触发器、视图等。</p></li><li><p>存储引擎层负责<strong>数据的存储和提取</strong>。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始成为了默认存储引擎。也就是说，你执行createtable建表的时候，如果不指定引擎类型，<strong>默认使用的就是InnoDB</strong>。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在<code>create table</code>语句中使用<code>engine=memory</code>,来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p></li></ol><h3 id="连接器">1.1 连接器</h3><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h$ip -P$port -u$user -p<br></code></pre></td></tr></table></figure><p>连接命令中的mysql是<strong>客户端工具</strong>，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li><p>如果用户名或密码不对，你就会收到一个<strong>"Access denied foruser"的错误</strong>，然后客户端程序结束执行。</p></li><li><p>如果用户名密码认证通过，连接器会到<strong>权限表里面查出你拥有的权限</strong>。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有<strong>再新建的连接才会使用新的权限设置</strong>。</p></li></ul><p>客户端如果太<strong>长时间没动静</strong>，连接器就会<strong>自动将它断开</strong>。这个时间是由参数<code>wait_timeout</code>控制的，默认值是8小时。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：<code>Lost connection to MySQL server during query</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p><ul><li><strong>长连接</strong>是指连接成功后，如果客户端<strong>持续有请求</strong>，则一直使用<strong>同一个连接</strong>。</li><li><strong>短连接</strong>则是指每次执行完很少的<strong>几次查询就断开连接</strong>，下次查询再重新建立一个。</li></ul><p><strong>建立连接的过程通常是比较复杂</strong>的，所以建议在使用中要尽量减少建立连接的动作，也就是<strong>尽量使用长连接</strong>。</p><p>但是全部使用长连接后，MySQL占用内存涨得特别快，这是因为MySQL在执行过程中<strong>临时使用的内存是管理在连接对象里面的</strong>。这些资源会在<strong>连接断开的时候才释放</strong>。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><ol type="1"><li><p><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断<strong>执行过一个占用内存的大查询后</strong>，断开连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行<code>mysql_reset_connection</code>来<strong>重新初始化连接资源</strong>。这个过程<strong>不需要重连</strong>和重新做权限验证，但是会<strong>将连接恢复到刚刚创建完时的状态</strong>。</p></li></ol><h3 id="查询缓存">1.2 查询缓存</h3><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。<strong>之前执行过的语句及其结果</strong>可能会以<strong>key-value对</strong>的形式，被直接缓存在内存中。<strong>key是查询的语句，value是查询的结果。</strong>如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个<strong>效率会很高</strong>。</p><p>但是大多数情况下<strong>建议不要使用查询缓存</strong>：查询缓存的<strong>失效非常频繁</strong>，只要有对一个<strong>表的更新</strong>，这个表上所有的<strong>查询缓存都会被清空</strong>。对于<strong>更新压力大的数据库</strong>来说，查询缓存的命中率会非常低。除非你的业务就是有一张<strong>静态表</strong>，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>在MySQL也提供了这种“按需使用”的方式。你可以将参数<code>query_cache_type</code>设置成<code>DEMAND</code>，这样对于<strong>默认的SQL语句都不使用查询缓存</strong>。而对于你<strong>确定要使用查询缓存的语句</strong>，可以用<code>SQL_CACHE</code>显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select SQL_CACHE * from T where ID=10；<br></code></pre></td></tr></table></figure><p>MySQL8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p><h3 id="分析器">1.3 分析器</h3><p>首先，MySQL需要<strong>知道你要做什么</strong>，因此需要对SQL语句做解析。</p><ul><li><p>分析器先会做<strong>“词法分析”</strong>。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的<strong>字符串分别是什么</strong>，代表什么。MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p></li><li><p>做完了这些识别以后，就要做<strong>“语法分析”</strong>。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句<strong>是否满足MySQL语法</strong>。如果你的语句不对，就会收到“You have an error in your SQLsyntax”的错误提醒，比如下面这个 语句select少打了开头的字母“s”。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; elect * from t where ID=1; <br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1 <br></code></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“usenear”的内容。</p><h3 id="优化器">1.4 优化器</h3><p>优化器是在表里面有<strong>多个索引</strong>的时候，决定使用哪个索引；或者在一个语句有<strong>多表关联</strong>（join）的时候，决定各个表的连接顺序。</p><p>比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;<br></code></pre></td></tr></table></figure><ul><li><p>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</p></li><li><p>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</p></li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h3 id="执行器">1.5 执行器</h3><p>MySQL通过<strong>分析器</strong>知道了你要<strong>做什么</strong>，通过<strong>优化器</strong>知道了该<strong>怎么做</strong>，于是就进入了执行器阶段，开始执行语句。</p><p>要先判断一下你对这个表T有没有<strong>执行查询的权限</strong>，如果没有，就会返回没有权限的错误，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from T where ID=10; <br>ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;<br></code></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去<strong>使用这个引擎提供的接口</strong>。</p><p>比如我们这个例子中的表T中，ID字段<strong>没有索引</strong>，那么执行器的执行流程是这样的：</p><ol type="1"><li><p>调用InnoDB引擎接口取这个表的<strong>第一行</strong>，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</p></li><li><p>调用引擎接口取<strong>“下一行”</strong>，重复相同的判断逻辑，直到取到这个表的最后一行。</p></li><li><p>执行器将上述<strong>遍历</strong>过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p></li></ol><p>至此，这个语句就执行完成了。</p><p>对于<strong>有索引</strong>的表，执行的逻辑也差不多。第一次调用的是<strong>“取满足条件的第一行”</strong>这个接口，之后循环取<strong>“满足条件的下一行”</strong>这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个<code>rows_examined</code>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础架构一条sql查询语句是如何执行的&quot;&gt;1.
基础架构：一条SQL查询语句是如何执行的？&lt;/h2&gt;
&lt;p&gt;下面是&lt;strong&gt;MySQL的基本架构&lt;/strong&gt;示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://yinan.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://yinan.fun/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据库" scheme="https://yinan.fun/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://yinan.fun/tags/MySQL/"/>
    
  </entry>
  
</feed>
