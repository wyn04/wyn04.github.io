<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>了解Llama</title>
    <link href="/%E4%BA%86%E8%A7%A3Llama.html"/>
    <url>/%E4%BA%86%E8%A7%A3Llama.html</url>
    
    <content type="html"><![CDATA[<h1 id="了解Llama"><a href="#了解Llama" class="headerlink" title="了解Llama"></a>了解Llama</h1><p>官网：<a href="https://ai.meta.com/llama/">https://ai.meta.com/llama/</a></p><p>文章：<a href="https://ai.meta.com/research/publications/llama-2-open-foundation-and-fine-tuned-chat-models/">https://ai.meta.com/research/publications/llama-2-open-foundation-and-fine-tuned-chat-models/</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>This release includes model weights and starting code for pretrained and fine-tuned Llama language models — ranging from 7B to 70B parameters(7B, 13B, 70B).</p><p>Llama 2 pretrained models are trained on 2 trillion tokens, and have double the context length than Llama 1. Its fine-tuned models have been trained on over 1 million human annotations.</p><p><strong>Auto-regressive transformers</strong> are <strong>pretrained</strong> on an extensive corpus of self-supervised data, followed by <strong>alignment</strong> with human preferences via techniques such as Reinforcement Learning with Human Feedback (RLHF).   </p><blockquote><p>Auto-regression is a time series model that <strong>uses observations from previous time steps as input</strong> to a regression equation to predict the value at the next time step</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230723111842222.png" alt="AT VS. NAT"></p><p>预训练，有监督微调，RLHF</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230721150225425.png" alt="Training of Llama 2-Chat"></p><p>The training methodology is simple, but high computational requirements.</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="预训练数据"><a href="#预训练数据" class="headerlink" title="预训练数据"></a>预训练数据</h3><ul><li><p>训练语料库包括来自公开来源的新数据组合，其中不包括来自 Meta 产品或服务的数据。</p></li><li><p>剔除某些已知包含大量个人隐私信息的网站的数据。</p></li><li><p>在 2 万亿个tokem的数据上进行了训练，很好地权衡性能与成本。</p></li><li><p>对最真实的数据源进行上采样，以增加知识和减少错误。</p></li></ul><h3 id="训练细节"><a href="#训练细节" class="headerlink" title="训练细节"></a>训练细节</h3><p>We adopt most of the <strong>pretraining setting and model architecture from Llama 1</strong>. We use the <strong>standard transformer architecture</strong> (Vaswani et al., 2017), apply pre-normalization using <strong>RMSNorm</strong> (Zhang and Sennrich, 2019), use the <strong>SwiGLU</strong> activation function (Shazeer, 2020), and <strong>rotary positional embeddings</strong> (RoPE, Su et al. 2022). The primary architectural differences from Llama 1 include increased <strong>context length</strong> and <strong>grouped-query attention</strong> (GQA).  </p><blockquote><p>GQA（Grouped-Query Attention）是分组查询注意力，GQA将查询头分成G组，每个组共享一个Key 和 Value 矩阵。GQA-G是指具有G组的grouped-query attention。其中多个查询头关注相同的键和值头，以减少推理过程中 KV 缓存的大小，并可以显著提高推理吞吐量。GQA-1具有单个组，因此具有单个Key 和 Value，等效于MQA。而GQA-H具有与头数相等的组，等效于MHA。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230723112453383.png" alt="Llama 2 family of models  "></p><ul><li><p>Hyperparameters</p><p>We trained using the <strong>AdamW optimizer</strong> (Loshchilov and Hutter, 2017), with β1 &#x3D; 0.9, β2 &#x3D; 0.95, eps &#x3D; 10-5. We use a <strong>cosine learning rate schedule</strong>, with warmup of 2000 steps, and decay final learning rate down to 10% of the peak learning rate. We use a weight decay of 0.1 and gradient clipping of 1.0.</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230723115454030.png" alt="Training Loss for Llama 2 models"></p><ul><li><p>Tokenizer</p><p>We use the same tokenizer as Llama 1; it employs a <strong>bytepair encoding</strong> (BPE) algorithm (Sennrich et al., 2016) using the implementation from SentencePiece (Kudo and Richardson, 2018). As with Llama 1, we split all numbers into individual digits and use bytes to decompose unknown UTF-8 characters. The total vocabulary size is 32k tokens.  </p></li><li><p>Llama 2预训练模型评估</p><ul><li>和开源模型对比，Llama 2性能最好。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230723120200445.png" alt="Overall performance on grouped academic benchmarks compared to open-source base models"></p><ul><li>和闭源模型对比，Llama 2有很大的性能差距。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230723120239606.png" alt="Comparison to closed-source models"></p></li></ul><h2 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h2><h3 id="Supervised-Fine-Tuning-SFT"><a href="#Supervised-Fine-Tuning-SFT" class="headerlink" title="Supervised Fine-Tuning (SFT)"></a>Supervised Fine-Tuning (SFT)</h3><p>For the fine-tuning process, each sample consists of a prompt and an answer. To ensure the model sequence length is properly filled, we <strong>concatenate all the prompts and answers</strong> from the training set. A special token is utilized to separate the prompt and answer segments. We utilize an autoregressive objective and zero-out the loss on tokens from the user prompt, so as a result, we backpropagate only on answer tokens. Finally, we fine-tune the model for 2 epochs.  </p><h3 id="Reinforcement-Learning-with-Human-Feedback-RLHF"><a href="#Reinforcement-Learning-with-Human-Feedback-RLHF" class="headerlink" title="Reinforcement Learning with Human Feedback (RLHF)"></a>Reinforcement Learning with Human Feedback (RLHF)</h3><p>RLHF is a model training procedure that is applied to a fine-tuned language model to <strong>further align model behavior with human preferences and instruction following</strong>. We collect data that represents empirically sampled human preferences, whereby human annotators select which of two model outputs they prefer. This human feedback is subsequently used to <strong>train a reward model</strong>, which learns patterns in the preferences of the human annotators and can then automate preference decisions.  </p><h2 id="使用Llama"><a href="#使用Llama" class="headerlink" title="使用Llama"></a>使用Llama</h2><p><a href="https://huggingface.co/docs/transformers/main/en/model_doc/llama">https://huggingface.co/docs/transformers/main/en/model_doc/llama</a></p><p><a href="https://huggingface.co/docs/transformers/main/en/model_doc/llama2">https://huggingface.co/docs/transformers/main/en/model_doc/llama2</a></p><ul><li>下载模型参数。Weights for the LLaMA models can be obtained from by filling out <a href="https://docs.google.com/forms/d/e/1FAIpQLSfqNECQnMkycAp2jP4Z9TFX0cGR4uf7b_fBxjY_OjhJILlKGA/viewform?usp=send_form">this form</a></li><li>转换为Hugging Face格式。After downloading the weights, they will need to be converted to the Hugging Face Transformers format using the <a href="https://github.com/huggingface/transformers/blob/main/src/transformers/models/llama/convert_llama_weights_to_hf.py">conversion script</a>. The script can be called with the following (example) command:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python src/transformers/models/llama/convert_llama_weights_to_hf.py \<br>    --input_dir /path/to/downloaded/llama/weights --model_size 7B --output_dir /output/path<br></code></pre></td></tr></table></figure><ul><li>加载模型和tokenizer。After conversion, the model and tokenizer can be loaded via:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> LlamaForCausalLM, LlamaTokenizer<br><br>tokenizer = LlamaTokenizer.from_pretrained(<span class="hljs-string">&quot;/output/path&quot;</span>)<br>model = LlamaForCausalLM.from_pretrained(<span class="hljs-string">&quot;/output/path&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调试运行华驼模型</title>
    <link href="/%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E5%8D%8E%E9%A9%BC%E6%A8%A1%E5%9E%8B.html"/>
    <url>/%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E5%8D%8E%E9%A9%BC%E6%A8%A1%E5%9E%8B.html</url>
    
    <content type="html"><![CDATA[<h1 id="调试运行华驼模型"><a href="#调试运行华驼模型" class="headerlink" title="调试运行华驼模型"></a>调试运行华驼模型</h1><p>论文地址：<a href="https://arxiv.org/abs/2304.06975">https://arxiv.org/abs/2304.06975</a></p><p>项目地址：<a href="https://github.com/SCIR-HI/Huatuo-Llama-Med-Chinese">https://github.com/SCIR-HI/Huatuo-Llama-Med-Chinese</a></p><ul><li><p>运行<code>infer.py</code>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">UnicodeDecodeError: <span class="hljs-string">&#x27;gbk&#x27;</span> codec can<span class="hljs-string">&#x27;t decode byte 0xae in position 84: illegal </span><br><span class="hljs-string">multibyte sequence</span><br></code></pre></td></tr></table></figure><p>修改<code>prompter.py </code>21行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br></code></pre></td></tr></table></figure><p>修改<code>infer.py </code>18行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(instruct_dir, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br></code></pre></td></tr></table></figure></li><li><p>运行<code>infer.py</code>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">HFValidationError: Repo <span class="hljs-built_in">id</span> must use alphanumeric chars or <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;--&#x27;</span> <br>and <span class="hljs-string">&#x27;..&#x27;</span> are forbidden, <span class="hljs-string">&#x27;-&#x27;</span> and <span class="hljs-string">&#x27;.&#x27;</span> cannot start or end the name, max length is<br>96: <span class="hljs-string">&#x27;&#x27;</span>.<br></code></pre></td></tr></table></figure><p>尝试下载模型参数，调用本地模型参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">base_model: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;./llama-7b-hf&quot;</span>,<br></code></pre></td></tr></table></figure></li><li><p>运行<code>infer.py</code>报错（使用CPU）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">The current device_map had weights offloaded to the disk. Please provide an offload_folder <span class="hljs-keyword">for</span> them. Alternatively, make sure you have safetensors installed <span class="hljs-keyword">if</span> the model you are using offers the weights <span class="hljs-keyword">in</span> this format<br></code></pre></td></tr></table></figure><p><a href="https://github.com/huggingface/transformers/issues/18698">https://github.com/huggingface/transformers/issues/18698</a> 这里说</p><p>There is no support for using the CPU as a main device in Accelerate yet. If you want to use the model on CPU, just don’t specific <code>device_map=&quot;auto&quot;</code>.</p><p>参数去掉<code>device_map=&quot;auto&quot;</code></p></li><li><p>修改<code>infer.py </code>13行（使用CPU）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">device = <span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>运行<code>infer.py</code>报错（使用CPU）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">RuntimeError: <span class="hljs-string">&quot;addmm_impl_cpu_&quot;</span> not implemented <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;Half&#x27;</span><br></code></pre></td></tr></table></figure><p>CPU无法使用 <code>fp16</code>（半精度），把 <code>model.half()</code>，改成<code>model.float()</code></p></li><li><p>未微调模型结果（CPU跑了两个小时）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">###infering###</span><br><span class="hljs-comment">###instruction###</span><br>小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。<br><span class="hljs-comment">###golden output###</span><br>小张可能患有心肌炎，建议进行心电图和心脏超声等检查来确定诊断。治疗方案包括使用泼尼松、生脉饮和三磷酸腺苷等药物，同时建议适当控制体温，保持良好的营养状况。<br><span class="hljs-comment">###model output###</span><br>小张感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。 问题：小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。 问题：小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。 问题：小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减��<br></code></pre></td></tr></table></figure></li><li><p>微调模型结果（基于医学知识库对<code>LLaMA</code>进行指令微调的<code>LoRA</code>权重文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">using lora ./lora-llama-med<br><span class="hljs-comment">###infering###</span><br><span class="hljs-comment">###instruction###</span><br>小张最近感觉身体不适，出现心悸、气促等症状。体检发现心脏扩大、搏动减弱。<br><span class="hljs-comment">###golden output###</span><br>小张可能患有心肌炎，建议进行心电图和心脏超声等检查来确定诊断。治疗方案包括使用泼尼松、生脉饮和三磷酸腺苷等药物，同时建议适当控制体温，保持良好的营养状况。<br><span class="hljs-comment">###model output###</span><br>小张可能患有心肌炎，需要进行心脏超声、心电图检查等辅助检查以确定诊断。治疗方案包括使用抗生素、抗坏血酸等药物进行治疗，同时建议加强营养，避免过度劳累。&lt;/s&gt;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Idea快捷键</title>
    <link href="/Idea%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
    <url>/Idea%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA开发常用快捷键"><a href="#IDEA开发常用快捷键" class="headerlink" title="IDEA开发常用快捷键"></a>IDEA开发常用快捷键</h1><table><thead><tr><th>快捷键组合</th><th>实现效果</th></tr></thead><tbody><tr><td>psvm + Tab键 &#x2F; main + Tab键</td><td>public static void main(String[] args)</td></tr><tr><td>sout + Tab键</td><td>System.out.println()</td></tr><tr><td>Ctrl + X</td><td>删除当前行</td></tr><tr><td>Ctrl +D</td><td>复制当前行</td></tr><tr><td>Alt+Insert(或右键Generate)</td><td>生成代码(如get,set方法,构造函数等)</td></tr><tr><td>Ctrl+Alt+T</td><td>生成try catch （或者 Alt+enter选择）</td></tr><tr><td>CTRL+ALT+T</td><td>把选中的代码放在 TRY{} IF{} ELSE{} 里</td></tr><tr><td>Ctr+shift+U</td><td>实现大小写之间的转化</td></tr><tr><td>ALT+回车</td><td>导入包,自动修正</td></tr><tr><td>CTRL+ALT+L</td><td>格式化代码</td></tr><tr><td>CTRL+ALT+I</td><td>自动缩进</td></tr><tr><td>CTRL+E</td><td>最近更改的代码</td></tr><tr><td>fori</td><td>生成for (int i &#x3D; 0; i &lt; ; i++) {}</td></tr><tr><td>Alt + &lt;–左右–&gt;键</td><td>实现窗口左右更换（多窗口）</td></tr><tr><td>Ctrl + 鼠标点击</td><td>快速找到成员变量的出处</td></tr><tr><td>Shift+F6</td><td>重构&#x2F;重命名 (包、类、方法、变量、甚至注释等)</td></tr><tr><td>CTRL+Q</td><td>查看当前方法的声明</td></tr><tr><td>Ctrl+Alt+V</td><td>自动创建变量（new 对象();之后选择按快捷键）</td></tr><tr><td>Ctrl+O</td><td>重写方法</td></tr><tr><td>Ctrl+I</td><td>实现方法</td></tr><tr><td>ALT+&#x2F;</td><td>代码提示</td></tr><tr><td>Ctrl+Shift+R</td><td>在当前项目中替换指定内容</td></tr><tr><td>Ctrl+E</td><td>最近编辑的文件列表</td></tr><tr><td>Ctrl+P</td><td>显示方法参数信息</td></tr><tr><td>Ctrl+Shift+Insert</td><td>查看历史复制记录，idea可以保留历史复制的 100 条记录</td></tr></tbody></table><h2 id="控制台语句-System-out-相关："><a href="#控制台语句-System-out-相关：" class="headerlink" title="控制台语句 System.out 相关："></a>控制台语句 System.out 相关：</h2><table><thead><tr><th>生成控制台的相关快捷键</th><th>描述</th></tr></thead><tbody><tr><td>sout + Tab键</td><td>生成System.out.println();，输出到控制台语句并换行。</td></tr><tr><td>souf + Tab键</td><td>生成System.out.printf(“”);,输出一个格式化字符串到控制台。</td></tr><tr><td>soutm + Tab键</td><td>生成System.out.println(“类名.方法名”);，输出当前 类和方法名 到控制台。</td></tr><tr><td>soutp + Tab键</td><td>生成System.out.println(所有方法参数名+值);，输出当前 方法的参数名和值 到控制台。</td></tr></tbody></table><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找</td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换</td></tr><tr><td>Shift + Ctrl + F</td><td>在项目进行文本查找</td></tr><tr><td>Shift + Ctrl + R</td><td>在项目进行文本替换</td></tr><tr><td>Shift + Shift</td><td>快速搜索</td></tr><tr><td>Ctrl + N</td><td>查找class</td></tr><tr><td>Ctrl + Shift + N</td><td>查找文件</td></tr><tr><td>Ctrl + Shift + Alt + N</td><td>查找symbol（查找某个方法名）</td></tr></tbody></table><h2 id="跳转切换"><a href="#跳转切换" class="headerlink" title="跳转切换"></a>跳转切换</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + E</td><td>最近文件</td></tr><tr><td>Ctrl + Tab</td><td>切换文件</td></tr><tr><td>Ctrl + Alt + ←&#x2F;→</td><td>跳转历史光标所在处</td></tr><tr><td>Alt + ←&#x2F;→ 方向键</td><td>切换子tab</td></tr><tr><td>Ctrl + G</td><td>go to（跳转指定行号）</td></tr></tbody></table><h2 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a>编码相关</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + W</td><td>快速选中</td></tr><tr><td>(Shift + Ctrl) + Alt + J</td><td>快速选中同文本</td></tr><tr><td>Ctrl + C&#x2F;Ctrl + X&#x2F;Ctrl + D</td><td>快速复制或剪切</td></tr><tr><td>多行选中 Tab &#x2F; Shift + Tab</td><td>tab</td></tr><tr><td>Ctrl + Y</td><td>删除整行</td></tr><tr><td>滚轮点击变量&#x2F;方法&#x2F;类</td><td>快速进入变量&#x2F;方法&#x2F;类的定义处</td></tr><tr><td>Shift + 点击Tab</td><td>快速关闭tab</td></tr><tr><td>Ctrl + Z 、Ctrl + Shift + Z</td><td>后悔药，撤销&#x2F;取消撤销</td></tr><tr><td>Ctrl + Shift + enter</td><td>自动收尾，代码自动补全</td></tr><tr><td>Alt + enter</td><td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td></tr><tr><td>Alt + ↑&#x2F;↓</td><td>方法快速跳转</td></tr><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置</td></tr><tr><td>Alt + Insert</td><td>代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等</td></tr><tr><td>Ctrl + Shift + L</td><td>格式化代码</td></tr><tr><td>Shift + F6</td><td>快速修改方法名、变量名、文件名、类名等</td></tr><tr><td>Ctrl + F6</td><td>快速修改方法签名</td></tr></tbody></table><h2 id="代码阅读相关"><a href="#代码阅读相关" class="headerlink" title="代码阅读相关"></a>代码阅读相关</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Shift + i</td><td>就可以在当前类里再弹出一个窗口出来</td></tr><tr><td>Alt + F7</td><td>可以列出变量在哪些地方被使用了</td></tr><tr><td>光标在子类接口名，Ctrl + u</td><td>跳到父类接口</td></tr><tr><td>Alt + F1 + 1， esc</td><td></td></tr><tr><td>(Shift) + Ctrl + +&#x2F;-</td><td>代码块折叠</td></tr><tr><td>Ctrl + Shift + ←&#x2F;→</td><td>移动窗口分割线</td></tr><tr><td>Ctrl + (Alt) + B</td><td>跳转方法定义&#x2F;实现</td></tr><tr><td>Ctrl + H</td><td>类的层级关系</td></tr><tr><td>Ctrl + F12</td><td>Show Members 类成员快速显示</td></tr></tbody></table><h2 id="版本管理相关"><a href="#版本管理相关" class="headerlink" title="版本管理相关"></a>版本管理相关</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + D</td><td>Show Diff</td></tr><tr><td>(Shift) + F7</td><td>（上）下一处修改</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快捷键</tag>
      
      <tag>Idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Domain-Adversarial Training of Neural Networks（DaNN）实现</title>
    <link href="/Domain-Adversarial-Training-of-Neural-Networks%EF%BC%88DaNN%EF%BC%89%E5%AE%9E%E7%8E%B0.html"/>
    <url>/Domain-Adversarial-Training-of-Neural-Networks%EF%BC%88DaNN%EF%BC%89%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h1 id="Domain-Adversarial-Training-of-Neural-Networks（DaNN）实现"><a href="#Domain-Adversarial-Training-of-Neural-Networks（DaNN）实现" class="headerlink" title="Domain-Adversarial Training of Neural Networks（DaNN）实现"></a>Domain-Adversarial Training of Neural Networks（DaNN）实现</h1><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>在传统的机器学习中，我们经常需要<strong>大量带标签的数据</strong>进行训练， 并且需要保证<strong>训练集和测试集中的数据分布相似</strong>。在一些问题中，如果训练集和测试集的数据具有不同的分布，训练后的分类器在测试集上就没有好的表现。</p><p><strong>域适应</strong>（Domain Adaption）是<strong>迁移学习</strong>中一个重要的分支，目的是把具有不同分布的<strong>源域</strong>(Source Domain) 和<strong>目标域</strong> (Target Domain) 中的数据，映射到同一个特征空间，寻找某一种度量准则，使其在这个空间上的“距离”尽可能近。然后，我们在源域 (带标签) 上训练好的分类器，就可以直接用于目标域数据的分类。</p><p><strong>DaNN</strong>是一种域适应学习方法，它采用了GAN的思想。为了使模型在目标集上也能有好的表现，它的目的是使模型特征提取器在源域和目标域提取的特征具有相同的分布。</p><p>DANN结构主要包含3个部分：</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713155252247.png" alt="image-20230713155252247"></p><ul><li><strong>特征提取器</strong> （feature extractor） - 图示绿色部分，用来<strong>将数据映射到特定的特征空间</strong>，使标签预测器能够分辨出来自源域数据的类别的同时，域判别器无法区分数据来自哪个域。</li><li>标签预测器 （label predictor） - 图示蓝色部分，对来自源域的数据进行分类，尽可能分出<strong>正确的标签</strong>。</li><li><strong>域判别器</strong>（domain classifier）- 图示红色部分，对特征空间的数据进行分类，尽可能分出<strong>数据来自哪个域</strong>。</li></ul><p>对抗迁移网络的总损失由两部分构成：网络的训练损失（标签预测器损失）和域判别损失。</p><p>我们通过最小化目标函数来更新标签预测器的参数，最大化目标函数来更新域判别器的参数。</p><p>相关论文：<a href="https://arxiv.org/abs/1505.07818">https://arxiv.org/abs/1505.07818</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>特征提取器实现，VGG网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FeatureExtractor</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(FeatureExtractor, self).__init__()<br><br>        self.conv = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">128</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">128</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">256</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">256</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.conv(x).squeeze()<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>标签预测器实现，由线性层组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LabelPredictor</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(LabelPredictor, self).__init__()<br><br>        self.layer = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, h</span>):<br>        c = self.layer(h)<br>        <span class="hljs-keyword">return</span> c<br></code></pre></td></tr></table></figure><p>域判别器实现，由线性层组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DomainClassifier</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(DomainClassifier, self).__init__()<br><br>        self.layer = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">512</span>),<br>            nn.ReLU(),<br><br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">1</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, h</span>):<br>        y = self.layer(h)<br>        <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></table></figure><p>损失函数选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">class_criterion = nn.CrossEntropyLoss()<br>domain_criterion = nn.BCEWithLogitsLoss()<br></code></pre></td></tr></table></figure><p>训练过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, ((source_data, source_label), (target_data, _)) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(source_dataloader, target_dataloader)):<br>    source_data = source_data.to(device)<br>    source_label = source_label.to(device)<br>    target_data = target_data.to(device)<br>    mixed_data = torch.cat([source_data, target_data], dim=<span class="hljs-number">0</span>)<br>    domain_label = torch.zeros([source_data.shape[<span class="hljs-number">0</span>] + target_data.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>]).to(device)<br>    domain_label[:source_data.shape[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 1. 先训练domain classifier</span><br>    feature = feature_extractor(mixed_data)<br>    domain_logits = domain_classifier(feature.detach())<br>    loss = domain_criterion(domain_logits, domain_label)<br>    domain_classifier_losses.append(loss.item())<br>    running_D_loss += loss.item()<br>    loss.backward()<br>    optimizer_D.step()<br><br>    <span class="hljs-comment"># 2. 训练 feature extractor 和 label classifier</span><br>    class_logits = label_predictor(feature[:source_data.shape[<span class="hljs-number">0</span>]])<br>    domain_logits = domain_classifier(feature)<br>    loss = class_criterion(class_logits, source_label) - lamb * domain_criterion(domain_logits, domain_label)<br>    total_losses.append(loss.item())<br>    running_F_loss += loss.item()<br>    loss.backward()<br>    optimizer_F.step()<br>    optimizer_C.step()<br><br>    optimizer_D.zero_grad()<br>    optimizer_F.zero_grad()<br>    optimizer_C.zero_grad()<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>训练损失上下波动，是特征提取器和域判别器在不断对抗。</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713171352103.png" alt="image-20230713171352103"></p><p>训练10、100、200个epoch后，特征提取器提取的特征分布按类别和source&#x2F;target展示。可以看到，随着训练的过程，特征越来越能区分不同的类，source和target domain的分布越来越一致。</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713171446520.png" alt="image-20230713171446520"></p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713171459818.png" alt="image-20230713171459818"></p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230713171519185.png" alt="image-20230713171519185"></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解ChatGPT</title>
    <link href="/%E4%BA%86%E8%A7%A3ChatGPT.html"/>
    <url>/%E4%BA%86%E8%A7%A3ChatGPT.html</url>
    
    <content type="html"><![CDATA[<h1 id="了解ChatGPT"><a href="#了解ChatGPT" class="headerlink" title="了解ChatGPT"></a>了解ChatGPT</h1><h2 id="1-ChatGPT的功能"><a href="#1-ChatGPT的功能" class="headerlink" title="1. ChatGPT的功能"></a>1. ChatGPT的功能</h2><p>如果我们向ChatGPT询问ChatGPT的<strong>功能</strong>：</p><p>ChatGPT具有以下功能：</p><ol><li>回答问题：ChatGPT可以<strong>回答各种问题</strong>，包括常见知识、事实、定义、历史事件等。</li><li>提供解释：ChatGPT可以<strong>解释复杂的概念</strong>、原理、术语等，并帮助你更好地理解。</li><li>提供建议：ChatGPT可以<strong>提供关于各种主题的建议</strong>，例如旅行目的地、电影推荐、食谱等。</li><li>进行对话：ChatGPT可以<strong>进行对话</strong>，你可以与它交流，分享观点、提问问题或寻求帮助。</li><li>写作辅助：如果你需要<strong>写作文章</strong>、创作故事或撰写邮件，ChatGPT可以<strong>提供灵感</strong>、提供写作建议和进行文本生成。</li></ol><p>请注意，尽管ChatGPT具备广泛的知识和语言理解能力，但它仍然是一个模型，<strong>可能会出现错误或提供不准确的答案</strong>。在使用时，请谨慎评估和验证信息的准确性。（ChatGPT生成）</p><p>另外，从OpenAI的官网我们可以了解到，ChatGPT<strong>以对话的方式进行交互</strong>，对话形式使ChatGPT能够回答后续问题、承认错误、质疑不正确的前提并拒绝不适当的请求。</p><p>OpenAI的官网也列出了ChatGPT的<strong>缺点</strong>，例如有时会回答看似有道理但是是错误或没意义的回答，对提问的方式敏感，模型过于冗长，在用户询问模糊的问题时猜测用户的想法。</p><h2 id="2-ChatGPT的原理"><a href="#2-ChatGPT的原理" class="headerlink" title="2. ChatGPT的原理"></a>2. ChatGPT的原理</h2><p>如果我们向ChatGPT询问ChatGPT的<strong>原理</strong>：</p><p>ChatGPT的实现是基于<strong>深度学习</strong>和<strong>自监督学习</strong>的方法。下面将详细说明ChatGPT的实现过程：</p><ol><li>数据收集：为了<strong>预训练</strong>ChatGPT，大量的互联网<strong>文本数据</strong>被收集和准备。这些数据可以包括网页内容、书籍、维基百科、新闻文章等。这些文本数据被用来构建一个庞大的语料库，作为模型的训练数据。</li><li>构建Transformer模型：ChatGPT是基于<strong>Transformer</strong>模型构建的。Transformer模型是一种使用自注意力机制（self-attention）的序列到序列模型，它能够处理长距离依赖关系并捕捉上下文信息。Transformer模型由多个编码器和解码器层组成，每个层都包含多头注意力机制和前馈神经网络。</li><li>预训练：在<strong>预训练</strong>阶段，ChatGPT使用大规模的语料库进行训练。模型通过<strong>自监督学习</strong>的方式进行预训练，即在没有人工标注的情况下进行训练。预训练的目标是<strong>预测下一个单词或标记</strong>。通过这种方式，模型能够学习到语言的统计规律、语义关系和上下文信息。预训练使用了大量的计算资源和并行计算，通常需要花费数天甚至数周的时间。</li><li>微调：在预训练之后，ChatGPT需要进行<strong>微调</strong>以<strong>适应特定的任务</strong>。对于对话式交互，微调阶段通常使用<strong>对话数据</strong>进行训练。对话数据包括用户的问题和模型的回答。通过在这些对话数据上进行微调，模型能够更好地理解和生成对话，并提供准确的回答。</li><li>模型优化和部署：在微调之后，ChatGPT需要进行<strong>模型优化和部署</strong>，以提高性能和效率。这包括模型的压缩、加速和优化，以便在实际应用中能够快速响应用户的请求。</li></ol><p>需要注意的是，ChatGPT的实现过程非常复杂，并需要大量的计算资源和数据。OpenAI团队在实现ChatGPT时投入了大量的研究和工程工作，以使其具备强大的语言理解和生成能力。（ChatGPT生成）</p><p>OpenAI的官网简要说明了ChatGPT的方法。模型训练使用了<strong>Reinforcement Learning from Human Feedback</strong> (RLHF)，即以强化学习方式依据人类反馈优化语言模型。开始使用有监督的微调训练初始模型。然后收集comparison data为强化学习训练一个奖励模型（reward model）。最后使用Proximal Policy Optimization强化学习算法微调模型。</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/ChatGPT_Diagram.svg" alt="Chatgpt Diagram"></p><p>OpenAI的官网说：We trained this model using Reinforcement Learning from Human Feedback (RLHF), using the same methods as <a href="https://openai.com/blog/instruction-following/"><strong>InstructGPT</strong></a>, but with slight differences in the data collection setup. 因此，要了解更多关于ChatGPT也可以阅读instructGPT的论文：<a href="https://arxiv.org/abs/2203.02155%E3%80%82">https://arxiv.org/abs/2203.02155。</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
      <tag>语言模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爱楼表情包网站</title>
    <link href="/%E7%88%B1%E6%A5%BC%E8%A1%A8%E6%83%85%E5%8C%85%E7%BD%91%E7%AB%99.html"/>
    <url>/%E7%88%B1%E6%A5%BC%E8%A1%A8%E6%83%85%E5%8C%85%E7%BD%91%E7%AB%99.html</url>
    
    <content type="html"><![CDATA[<h1 id="爱楼-表情包网站"><a href="#爱楼-表情包网站" class="headerlink" title="爱楼-表情包网站"></a>爱楼-表情包网站</h1><h2 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h2><ul><li>主页</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230717161539797.png" alt="image-20230717161539797"></p><ul><li>管理员页面</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230717161629434.png" alt="image-20230717161629434"></p><ul><li>后端文档</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230717161823777.png" alt="image-20230717161823777"></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>用户根据名字和标签搜索表情包</li><li>用户上传表情包</li><li>管理员管理表情包</li></ol><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>框架：Vue 3</li><li>组件库：Ant Design Vue</li><li>请求：Axios</li><li>路由：Vue Router</li><li>文件下载：FileSaver</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>Java 8</li><li>开发框架：SpringBoot 2.x</li><li>数据访问：MyBatis + MyBatis Plus</li><li>缓存：Redis</li><li>项目管理：Maven</li><li>接口文档：Swagger + Knife4j</li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul><li>数据库：MySQL</li><li>对象存储：七牛云 COS</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul><li>前端：Nginx + Docker</li><li>后端：Docker容器</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>使用 Redis 缓存首页高频访问的表情包列表，将接口响应时长从120毫秒缩短至 20毫秒。  </li><li>选用 MyBatis + MyBatis-Plus 进行数据访问层开发，复用大多数通用方法，并且通过继承定制了自己的通用操作模板 ，大幅提升了项目开发效率。  </li><li>为了明确接口的返回，自定义统一的错误码，并封装了全局异常处理器 ，从而规范了异常返回、屏蔽了项目冗余的报错细节。  </li><li>自主编写 Dockerfile，并通过容器部署，提高部署上线效率。  </li><li>使用 Knife4j + Swagger 自动生成后端接口文档，避免了人工编写维护文档的麻烦。  </li><li>前端使用 Vant UI 组件库，并封装了全局通用的 Layout 组件，使主页、搜索页、管理页布局一致、并减少重复代码。</li></ol><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><strong>数据库名：</strong> ilou</p><table><thead><tr><th align="left">表名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="#emoji">emoji</a></td><td align="left">表情</td></tr><tr><td align="left"><a href="#tag">tag</a></td><td align="left">标签</td></tr></tbody></table><p><strong>表名：</strong> <a id="tag">emoji</a></p><p><strong>说明：</strong> 表情</p><p><strong>数据列：</strong></p><table><thead><tr><th align="center">序号</th><th align="left">名称</th><th align="center">数据类型</th><th align="center">长度</th><th align="center">小数位</th><th align="center">允许空值</th><th align="center">主键</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">id</td><td align="center">int</td><td align="center">10</td><td align="center">0</td><td align="center">N</td><td align="center">Y</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2</td><td align="left">url</td><td align="center">varchar</td><td align="center">4096</td><td align="center">0</td><td align="center">Y</td><td align="center">N</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="left">name</td><td align="center">varchar</td><td align="center">512</td><td align="center">0</td><td align="center">Y</td><td align="center">N</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="left">userId</td><td align="center">int</td><td align="center">10</td><td align="center">0</td><td align="center">Y</td><td align="center">N</td><td align="center">0</td><td align="center">上传用户id</td></tr><tr><td align="center">5</td><td align="left">tags</td><td align="center">varchar</td><td align="center">1024</td><td align="center">0</td><td align="center">Y</td><td align="center">N</td><td align="center"></td><td align="center">标签数组json</td></tr><tr><td align="center">6</td><td align="left">reviewStatus</td><td align="center">int</td><td align="center">10</td><td align="center">0</td><td align="center">N</td><td align="center">N</td><td align="center">0</td><td align="center">0-待审核,1-通过,2-拒绝</td></tr><tr><td align="center">7</td><td align="left">createTime</td><td align="center">datetime</td><td align="center">19</td><td align="center">0</td><td align="center">Y</td><td align="center">N</td><td align="center">CURRENT_TIMESTAMP</td><td align="center"></td></tr><tr><td align="center">8</td><td align="left">isDelete</td><td align="center">tinyint</td><td align="center">3</td><td align="center">0</td><td align="center">N</td><td align="center">N</td><td align="center">0</td><td align="center">是否删除0-未删除1-已删除</td></tr><tr><td align="center">9</td><td align="left">updateTime</td><td align="center">datetime</td><td align="center">19</td><td align="center">0</td><td align="center">Y</td><td align="center">N</td><td align="center">CURRENT_TIMESTAMP</td><td align="center"></td></tr></tbody></table><p><strong>表名：</strong> <a id="tag">tag</a></p><p><strong>说明：</strong> 标签</p><p><strong>数据列：</strong></p><table><thead><tr><th align="center">序号</th><th align="left">名称</th><th align="center">数据类型</th><th align="center">长度</th><th align="center">小数位</th><th align="center">允许空值</th><th align="center">主键</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">id</td><td align="center">int</td><td align="center">10</td><td align="center">0</td><td align="center">N</td><td align="center">Y</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2</td><td align="left">name</td><td align="center">varchar</td><td align="center">512</td><td align="center">0</td><td align="center">N</td><td align="center">N</td><td align="center"></td><td align="center">标签名</td></tr><tr><td align="center">3</td><td align="left">createTime</td><td align="center">datetime</td><td align="center">19</td><td align="center">0</td><td align="center">Y</td><td align="center">N</td><td align="center">CURRENT_TIMESTAMP</td><td align="center"></td></tr><tr><td align="center">4</td><td align="left">isDelete</td><td align="center">tinyint</td><td align="center">3</td><td align="center">0</td><td align="center">N</td><td align="center">N</td><td align="center">0</td><td align="center">是否删除0-未删除1-已删除</td></tr><tr><td align="center">5</td><td align="left">updateTime</td><td align="center">datetime</td><td align="center">19</td><td align="center">0</td><td align="center">Y</td><td align="center">N</td><td align="center">CURRENT_TIMESTAMP</td><td align="center"></td></tr></tbody></table><h3 id="后端接口设计"><a href="#后端接口设计" class="headerlink" title="后端接口设计"></a>后端接口设计</h3><p><a href="ilou-api.yinan.fun/api/doc.html">ilou-api.yinan.fun&#x2F;api&#x2F;doc.html</a></p><h3 id="通用返回对象"><a href="#通用返回对象" class="headerlink" title="通用返回对象"></a>通用返回对象</h3><p>给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">SUCCESS(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;ok&quot;</span>),<br>PARAMS_ERROR(<span class="hljs-number">40000</span>, <span class="hljs-string">&quot;请求参数错误&quot;</span>),<br>NOT_LOGIN_ERROR(<span class="hljs-number">40100</span>, <span class="hljs-string">&quot;未登录&quot;</span>),<br>NO_AUTH_ERROR(<span class="hljs-number">40101</span>, <span class="hljs-string">&quot;无权限&quot;</span>),<br>NOT_FOUND_ERROR(<span class="hljs-number">40400</span>, <span class="hljs-string">&quot;请求数据不存在&quot;</span>),<br>FORBIDDEN_ERROR(<span class="hljs-number">40300</span>, <span class="hljs-string">&quot;禁止访问&quot;</span>),<br>SYSTEM_ERROR(<span class="hljs-number">50000</span>, <span class="hljs-string">&quot;系统内部异常&quot;</span>),<br>OPERATION_ERROR(<span class="hljs-number">50001</span>, <span class="hljs-string">&quot;操作失败&quot;</span>),<br>FILE_UPLOAD_ERROR(<span class="hljs-number">50010</span>, <span class="hljs-string">&quot;文件上传错误&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）</p></li></ol><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/wyn04/ilou">https://github.com/wyn04/ilou</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyInstaller python 打包工具使用</title>
    <link href="/PyInstaller-python-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.html"/>
    <url>/PyInstaller-python-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.html</url>
    
    <content type="html"><![CDATA[<h1 id="PyInstaller-python-打包工具使用"><a href="#PyInstaller-python-打包工具使用" class="headerlink" title="PyInstaller python 打包工具使用"></a>PyInstaller python 打包工具使用</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table><thead><tr><th>参数名</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>-D</td><td>生成one-folder的程序（默认）</td><td>生成结果是一个目录，各种第三方依赖、资源和exe同时存储在该目录</td></tr><tr><td>-F</td><td>生成one-file的程序</td><td>生成结果是一个exe文件，所有的第三方依赖、资源和代码均被打包进该exe内</td></tr><tr><td>–add-data</td><td>打包额外资源</td><td>用法：pyinstaller main.py –add-data&#x3D;src;dest。windows以;分割，macOS&#x2F;linux以:分割</td></tr><tr><td>-c</td><td>显示命令行窗口</td><td>与-w相反，默认含有此参数</td></tr><tr><td>-w</td><td>不显示命令行窗口</td><td>编写GUI程序时使用此参数有用。</td></tr><tr><td>-i</td><td>为main.exe指定图标</td><td>用法：pyinstaller -i beauty.ico main.py</td></tr></tbody></table><p>具体参数看：<a href="https://blog.csdn.net/weixin_39000819/article/details/80942423">https://blog.csdn.net/weixin_39000819/article/details/80942423</a></p><h2 id="打包图片等资源"><a href="#打包图片等资源" class="headerlink" title="打包图片等资源"></a>打包图片等资源</h2><p>即使使用了<code>–add-data</code>参数也大概率还是会出现图片文件没有找到的情况。</p><p>因为当app运行的时候，会先<strong>把资源解压到一个系统的临时目录</strong>，包括打包进去的 img文件等。但是，此时的代码并不能直接通过 “img&#x2F;texture.png” 这样的相对路径来得到文件,应该是因为本身程序就不在这里，所以自然引用不到。</p><p>这时需要用到 sys 的一个半私有的属性 <code>sys._MEIPASS</code>，根据官方的说明，它是 pyinstaller 运行时创建的<strong>临时目录的绝对路径</strong>。需要在程序运行时判断当前是不是有这个属性，如果有的话，使用生成临时目录下图片的绝对路径，如果没有的话，那就直接返回当前程序的绝对路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_resource_path</span>(<span class="hljs-params">relative_path</span>):<br>    <span class="hljs-comment"># 资源路径拼接当前运行时临时目录路径</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(sys, <span class="hljs-string">&#x27;_MEIPASS&#x27;</span>):<br>        <span class="hljs-keyword">return</span> os.path.join(sys._MEIPASS, relative_path)<br>    <span class="hljs-keyword">return</span> os.path.join(os.path.abspath(<span class="hljs-string">&quot;.&quot;</span>), relative_path)<br></code></pre></td></tr></table></figure><p>每次用到图片资源地址的时候都调用<code>get_resource_path</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">texture_filename = get_resource_path(<span class="hljs-string">&quot;img/texture.png&quot;</span>)<br>texture = cv2.imread(texture_filename)<br></code></pre></td></tr></table></figure><p>之后就可以使用下面的命令（windows要将<code>:</code>改成<code>;</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pyinstaller --add-data img:img -wF img2sketch.py</span><br></code></pre></td></tr></table></figure><p>在<code>disk</code>目录下生成可执行文件</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230522162328233.png" alt="image-20230522162328233"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker常用命令大全</title>
    <link href="/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html"/>
    <url>/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker常用命令大全"><a href="#Docker常用命令大全" class="headerlink" title="Docker常用命令大全"></a>Docker常用命令大全</h1><h2 id="1、帮助类启动命令"><a href="#1、帮助类启动命令" class="headerlink" title="1、帮助类启动命令"></a>1、帮助类启动命令</h2><ul><li>启动docker： systemctl start docker</li><li>停止docker： systemctl stop docker</li><li>重启docker： systemctl restart docker</li><li>查看docker状态： systemctl status docker</li><li>开机启动： systemctl enable docker</li><li>查看docker概要信息： docker info</li><li>查看docker总体帮助文档： docker –help</li><li>查看docker命令帮助文档： docker 具体命令 –help</li></ul><h2 id="2、镜像命令"><a href="#2、镜像命令" class="headerlink" title="2、镜像命令"></a>2、镜像命令</h2><h3 id="1、列出本地主机上的镜像"><a href="#1、列出本地主机上的镜像" class="headerlink" title="1、列出本地主机上的镜像"></a>1、列出本地主机上的镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/7000-20230417102853412.png" alt="img"></p><p>在这里插入图片描述</p><p>各个选项说明:</p><ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签版本号</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul><blockquote><p> 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p><p> 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</p></blockquote><p>OPTIONS说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a :列出本地所有的镜像（含历史映像层）<br><br>docker images -a<br><br><br><br>-q :只显示镜像ID。<br><br>docker images -q<br></code></pre></td></tr></table></figure><h3 id="2、搜索镜像"><a href="#2、搜索镜像" class="headerlink" title="2、搜索镜像"></a>2、搜索镜像</h3><p>官方搜索网址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search [OPTIONS] 镜像名字<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker search mysql<br><br>NAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br><br>mysql                            MySQL is a widely used, open-source relation…   12378     [OK]       <br><br>mariadb                          MariaDB Server is a high performing open sou…   4762      [OK]       <br><br>mysql/mysql-server               Optimized MySQL Server Docker images. Create…   917                  [OK]<br><br>percona                          Percona Server is a fork of the MySQL relati…   572       [OK]       <br><br>phpmyadmin                       phpMyAdmin - A web interface for MySQL and M…   494       [OK]       <br><br>mysql/mysql-cluster              Experimental MySQL Cluster Docker images. Cr…   93                   <br><br>centos/mysql-57-centos7          MySQL 5.7 SQL database server                   92                   <br><br>bitnami/mysql                    Bitnami MySQL Docker Image                      68                   [OK]<br><br>ubuntu/mysql                     MySQL open source fast, stable, multi-thread…   29                   <br><br>circleci/mysql                   MySQL is a widely used, open-source relation…   25                   <br><br>mysql/mysql-router               MySQL Router provides transparent routing be…   23                   <br><br>centos/mysql-56-centos7          MySQL 5.6 SQL database server                   22                   <br><br>google/mysql                     MySQL server for Google Compute Engine          21                   [OK]<br><br>vmware/harbor-db                 Mysql container for Harbor                      10                   <br><br>mysqlboy/docker-mydumper         docker-mydumper containerizes MySQL logical …   3                    <br><br>mysqlboy/mydumper                mydumper for mysql logcial backups              3                    <br><br>bitnami/mysqld-exporter                                                          2                    <br><br>ibmcom/mysql-s390x               Docker image for mysql-s390x                    2                    <br><br>mysql/mysql-operator             MySQL Operator for Kubernetes                   0                    <br><br>ibmcom/tidb-ppc64le              TiDB is a distributed NewSQL database compat…   0                    <br><br>mysqlboy/elasticsearch                                                           0                    <br><br>mysqleatmydata/mysql-eatmydata                                                   0                    <br><br>cimg/mysql                                                                       0                    <br><br>mysql/ndb-operator               MySQL NDB Operator for Kubernetes               0                    <br><br>mirantis/mysql  <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/7000.png" alt="img"></p><p>在这里插入图片描述</p><h4 id="OPTIONS说明："><a href="#OPTIONS说明：" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h4><ul><li>–limit : 只列出N个镜像，默认25个</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search --limit 5 redis<br></code></pre></td></tr></table></figure><h3 id="3、拉取（下载）镜像"><a href="#3、拉取（下载）镜像" class="headerlink" title="3、拉取（下载）镜像"></a>3、拉取（下载）镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 某个XXX镜像名字<br></code></pre></td></tr></table></figure><ul><li>docker pull 某个XXX镜像名字:TAG</li><li>docker pull 镜像名字</li></ul><blockquote><p>没有TAG就是最新版</p><p>等价于：docker pull 镜像名字:latest</p></blockquote><h3 id="4、查看镜像"><a href="#4、查看镜像" class="headerlink" title="4、查看镜像"></a>4、查看镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker system df 查看镜像/容器/数据卷所占的空间<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker system df<br><br>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br><br>Images          1         1         13.26kB   0B (0%)<br><br>Containers      1         0         0B        0B<br><br>Local Volumes   0         0         0B        0B<br><br>Build Cache     0         0         0B        0B<br><br>[root@docker ~]# <br></code></pre></td></tr></table></figure><h3 id="5、删除镜像"><a href="#5、删除镜像" class="headerlink" title="5、删除镜像"></a>5、删除镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi 某个XXX镜像名字ID<br></code></pre></td></tr></table></figure><h4 id="1、删除单个"><a href="#1、删除单个" class="headerlink" title="1、删除单个"></a>1、删除单个</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi  -f 镜像ID<br></code></pre></td></tr></table></figure><h4 id="2、删除多个"><a href="#2、删除多个" class="headerlink" title="2、删除多个"></a>2、删除多个</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi -f 镜像名1:TAG 镜像名2:TAG <br></code></pre></td></tr></table></figure><h3 id="3、删除全部"><a href="#3、删除全部" class="headerlink" title="3、删除全部"></a>3、删除全部</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi -f $(docker images -qa)<br></code></pre></td></tr></table></figure><h3 id="6、面试题：谈谈docker虚悬镜像是什么？"><a href="#6、面试题：谈谈docker虚悬镜像是什么？" class="headerlink" title="6、面试题：谈谈docker虚悬镜像是什么？"></a>6、面试题：谈谈docker虚悬镜像是什么？</h3><blockquote><p>仓库名、标签都是<none>的镜像，俗称虚悬镜像dangling image</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/7000-20230417102853439.png" alt="img"></p><p>在这里插入图片描述</p><h2 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h2><blockquote><p>有镜像才能创建容器</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/7000-20230417102853482.png" alt="img"></p><p>本次用centos进行演示</p><h3 id="1、新建-启动命令"><a href="#1、新建-启动命令" class="headerlink" title="1、新建+启动命令"></a>1、新建+启动命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><p> OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p><p>–name&#x3D;”容器新名字”       为容器指定一个名称；</p><p>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</p><p>-i：以交互模式运行容器，通常与 -t 同时使用；</p><p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>也即启动交互式容器(前台有伪终端，等待交互)；</p><p>-P: 随机端口映射，大写P</p><p>-p: 指定端口映射，小写p</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/7000-20230417102853467.png" alt="img"></p><p>在这里插入图片描述</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/7000-20230417102853397.png" alt="img"></p><p>在这里插入图片描述</p><blockquote><p>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行&#x2F;bin&#x2F;bash命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it centos /bin/bash <br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-i: 交互式操作。</p><p>-t: 终端。</p><p>centos : centos 镜像。</p><p>&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</p><p>要退出终端，直接输入 exit:</p><h3 id="2、列出当前所有正在运行的容器"><a href="#2、列出当前所有正在运行的容器" class="headerlink" title="2、列出当前所有正在运行的容器"></a>2、列出当前所有正在运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps [OPTIONS]<br></code></pre></td></tr></table></figure><blockquote><p>OPTIONS说明（常用）：</p><p>-a :列出当前所有正在运行的容器+历史上运行过的</p><p>-l :显示最近创建的容器。</p><p>-n：显示最近n个创建的容器。</p><p>-q :静默模式，只显示容器编号。</p></blockquote><h3 id="3、退出容器"><a href="#3、退出容器" class="headerlink" title="3、退出容器"></a>3、退出容器</h3><h4 id="1、exec退出"><a href="#1、exec退出" class="headerlink" title="1、exec退出"></a>1、<code>exec</code>退出</h4><blockquote><p>run进去容器，exit退出，容器停止</p></blockquote><h4 id="2、ctrl-p-q"><a href="#2、ctrl-p-q" class="headerlink" title="2、ctrl+p+q"></a>2、<code>ctrl+p+q</code></h4><blockquote><p>run进去容器，ctrl+p+q退出，容器不停止</p></blockquote><h3 id="4、启动已停止运行的容器"><a href="#4、启动已停止运行的容器" class="headerlink" title="4、启动已停止运行的容器"></a>4、启动已停止运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器ID或者容器名<br></code></pre></td></tr></table></figure><h3 id="5、重启容器"><a href="#5、重启容器" class="headerlink" title="5、重启容器"></a>5、重启容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart 容器ID或者容器名<br></code></pre></td></tr></table></figure><h3 id="6、停止容器"><a href="#6、停止容器" class="headerlink" title="6、停止容器"></a>6、停止容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop 容器ID或者容器名<br></code></pre></td></tr></table></figure><h3 id="7、强制停止容器"><a href="#7、强制停止容器" class="headerlink" title="7、强制停止容器"></a>7、强制停止容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill 容器ID或容器名<br></code></pre></td></tr></table></figure><h3 id="8、删除已停止的容器"><a href="#8、删除已停止的容器" class="headerlink" title="8、删除已停止的容器"></a>8、删除已停止的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器ID<br></code></pre></td></tr></table></figure><h4 id="一次性删除多个容器实例"><a href="#一次性删除多个容器实例" class="headerlink" title="一次性删除多个容器实例"></a>一次性删除多个容器实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -f $(docker ps -a -q)<br><br><br><br>docker ps -a -q | xargs docker rm<br></code></pre></td></tr></table></figure><p><code>docker ps -a -q</code>：查询进行的容器ID</p><h2 id="4、实操"><a href="#4、实操" class="headerlink" title="4、实操"></a>4、实操</h2><h3 id="1、启动守护式容器-后台服务器"><a href="#1、启动守护式容器-后台服务器" class="headerlink" title="1、启动守护式容器(后台服务器)"></a>1、启动守护式容器(后台服务器)</h3><blockquote><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的后台运行模式。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d 容器名<br></code></pre></td></tr></table></figure><p>#使用镜像centos:latest以后台模式启动一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d centos<br></code></pre></td></tr></table></figure><p>问题：然后docker ps -a 进行查看, 会发现容器已经退出很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~</p><h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><blockquote><p><a href="https://cloud.tencent.com/product/crs?from=20065&from_column=20065">redis</a> 前后台启动演示case（下载一个Redis6.0.8镜像演示）</p></blockquote><ul><li>前台交互式启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it redis<br></code></pre></td></tr></table></figure><ul><li>后台守护式启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d redis<br></code></pre></td></tr></table></figure><p>PS：启动容器后，先查看容器是否启动正常，往往伴随着<code>docker ps</code></p><h3 id="2、查看容器日志"><a href="#2、查看容器日志" class="headerlink" title="2、查看容器日志"></a>2、查看容器日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs 容器ID<br></code></pre></td></tr></table></figure><p>PS：容器ID可省略为前三位</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker ps <br><br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS      NAMES<br><br>94b526c73db2   redis     &quot;docker-entrypoint.s…&quot;   4 seconds ago   Up 3 seconds   6379/tcp   admiring\_poincare<br><br>[root@docker ~]# docker logs 94b<br><br>1:C 10 Apr 2022 09:50:03.396 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo<br><br>1:C 10 Apr 2022 09:50:03.396 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started<br><br>1:C 10 Apr 2022 09:50:03.396 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf<br><br>1:M 10 Apr 2022 09:50:03.397 \* monotonic clock: POSIX clock\_gettime<br><br>1:M 10 Apr 2022 09:50:03.398 \* Running mode=standalone, port=6379.<br><br>1:M 10 Apr 2022 09:50:03.399 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br><br>1:M 10 Apr 2022 09:50:03.399 # Server initialized<br><br>1:M 10 Apr 2022 09:50:03.399 # WARNING overcommit\_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit\_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit\_memory=1&#x27; for this to take effect.<br><br>1:M 10 Apr 2022 09:50:03.399 \* Ready to accept connections<br><br>[root@docker ~]# <br></code></pre></td></tr></table></figure><h3 id="3、查看容器内运行的进程"><a href="#3、查看容器内运行的进程" class="headerlink" title="3、查看容器内运行的进程"></a>3、查看容器内运行的进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top 容器ID<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker top 94b<br><br>UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD<br><br>polkitd             35360               35341               0                   17:50               ?                   00:00:00            redis-server \*:6379<br></code></pre></td></tr></table></figure><h3 id="4、查看容器内部细节"><a href="#4、查看容器内部细节" class="headerlink" title="4、查看容器内部细节"></a>4、查看容器内部细节</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 容器ID<br></code></pre></td></tr></table></figure><h3 id="5、进入容器内部"><a href="#5、进入容器内部" class="headerlink" title="5、进入容器内部"></a>5、进入容器内部</h3><h4 id="1、使用exec进入容器"><a href="#1、使用exec进入容器" class="headerlink" title="1、使用exec进入容器"></a>1、使用<code>exec</code>进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it 容器ID bashShell<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker exec -it 94b /bin/bash<br><br>root@94b526c73db2:/data# redis-c<br><br>redis-check-aof  redis-check-rdb  redis-cli        <br><br>root@94b526c73db2:/data# redis-cli <br><br>127.0.0.1:6379&gt; ping<br><br>PONG<br><br>127.0.0.1:6379&gt; set k1 v1<br><br>OK<br><br>127.0.0.1:6379&gt; get k1<br><br>&quot;v1&quot;<br><br>127.0.0.1:6379&gt; exit<br></code></pre></td></tr></table></figure><p>exec帮助命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# docker exec --help<br><br><br><br>Usage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br><br><br><br>Run a command in a running containe<br><br><br><br>Options:<br><br>  -d, --detach               Detached mode: run command in the background<br><br>      --detach-keys string   Override the key sequence for detaching a containe<br><br>  -e, --env list             Set environment variables<br><br>      --env-file list        Read in a file of environment variables<br><br>  -i, --interactive          Keep STDIN open even if not attached<br><br>      --privileged           Give extended privileges to the command<br><br>  -t, --tty                  Allocate a pseudo-TTY<br><br>  -u, --user string          Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])<br><br>  -w, --workdir string       Working directory inside the containe<br><br>[root@docker ~]# <br></code></pre></td></tr></table></figure><h4 id="2、使用attach进入容器"><a href="#2、使用attach进入容器" class="headerlink" title="2、使用attach进入容器"></a>2、使用<code>attach</code>进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach 容器ID<br></code></pre></td></tr></table></figure><h4 id="3、两者的区别"><a href="#3、两者的区别" class="headerlink" title="3、两者的区别"></a>3、两者的区别</h4><ul><li>attach 直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会导致容器的停止。</li><li>exec 是在容器中打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器的停止。</li></ul><p>PS：推荐大家使用<code>docker exec</code> 命令，因为退出容器终端，不会导致容器的停止。</p><h2 id="5、从容器内拷贝文件到主机上"><a href="#5、从容器内拷贝文件到主机上" class="headerlink" title="5、从容器内拷贝文件到主机上"></a>5、从容器内拷贝文件到主机上</h2><blockquote><p>把文件从容器内部复制到主机上</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp  容器ID:容器内路径 目的主机路径<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp 3065f084c80d:a.txt a.txt<br></code></pre></td></tr></table></figure><h2 id="6、导入和导出容器"><a href="#6、导入和导出容器" class="headerlink" title="6、导入和导出容器"></a>6、导入和导出容器</h2><h3 id="1、导出容器"><a href="#1、导出容器" class="headerlink" title="1、导出容器"></a>1、导出容器</h3><blockquote><p>export 导出容器的内容留作为一个tar归档文件对应import命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker export 容器ID &gt; 文件名.ta<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker /]# docker export 3065f084c80d &gt; centos.tar.gz<br><br>[root@docker /]# ll<br><br>总用量 233004<br><br>-rw-r--r--.   1 root root         0 4月  10 18:16 a.txt<br><br>lrwxrwxrwx.   1 root root         7 4月   9 15:59 bin -&gt; usr/bin<br><br>dr-xr-xr-x.   5 root root      4096 4月   9 16:06 boot<br><br>-rw-r--r--.   1 root root 238572032 4月  10 19:04 centos.tar.gz<br><br>drwxr-xr-x.  20 root root      3220 4月   9 16:29 dev<br><br>drwxr-xr-x.  86 root root      8192 4月  10 11:03 etc<br><br>drwxr-xr-x.   3 root root        22 4月   9 16:05 home<br><br>lrwxrwxrwx.   1 root root         7 4月   9 15:59 lib -&gt; usr/lib<br><br>lrwxrwxrwx.   1 root root         9 4月   9 15:59 lib64 -&gt; usr/lib64<br><br>drwxr-xr-x.   2 root root         6 4月  11 2018 media<br><br>drwxr-xr-x.   2 root root         6 4月  11 2018 mnt<br><br>drwxr-xr-x.   4 root root        34 4月   9 20:38 opt<br><br>dr-xr-xr-x. 124 root root         0 4月   9 16:29 proc<br><br>dr-xr-x---.   5 root root       176 4月   9 20:36 root<br><br>drwxr-xr-x.  31 root root       940 4月   9 21:01 run<br><br>lrwxrwxrwx.   1 root root         8 4月   9 15:59 sbin -&gt; usr/sbin<br><br>drwxr-xr-x.   2 root root         6 4月  11 2018 srv<br><br>dr-xr-xr-x.  13 root root         0 4月   9 16:29 sys<br><br>drwxrwxrwt.  13 root root      4096 4月  10 18:16 tmp<br><br>drwxr-xr-x.  13 root root       155 4月   9 15:59 us<br></code></pre></td></tr></table></figure><h3 id="2、导入容器"><a href="#2、导入容器" class="headerlink" title="2、导入容器"></a>2、导入容器</h3><blockquote><p>import 从tar包中的内容创建一个新的文件系统再导入为镜像对应export</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker /]# cat centos.tar.gz | docker import - xiaobear/centos:8.8<br><br>sha256:12e7a58fc36a755fa63a82f78364291de7271c3ade90f2f5581cc50bc2416cb2<br><br>[root@docker /]# docker images<br><br>REPOSITORY        TAG       IMAGE ID       CREATED              SIZE<br><br>xiaobear/centos   8.8       12e7a58fc36a   About a minute ago   231MB<br><br>redis             latest    7614ae9453d1   3 months ago         113MB<br><br>hello-world       latest    feb5d9fea6a5   6 months ago         13.3kB<br><br>centos            latest    5d0da3dc9764   6 months ago         231MB<br><br>[root@docker /]# <br></code></pre></td></tr></table></figure><h2 id="7、常用命令汇总"><a href="#7、常用命令汇总" class="headerlink" title="7、常用命令汇总"></a>7、常用命令汇总</h2><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/7000-20230417102853593.png" alt="img"></p><table><thead><tr><th>命令</th><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>attach</td><td>Attach to a running container</td><td>当前 shell 下 attach 连接指定运行镜像</td></tr><tr><td>build</td><td>Build an image from a Dockerfile</td><td>通过 Dockerfile 定制镜像</td></tr><tr><td>commit</td><td>Create a new image from a container changes</td><td>提交当前容器为新的镜像</td></tr><tr><td>cp</td><td>Copy files&#x2F;folders from the containers filesystem to the host path</td><td>容器中拷贝指定文件或者目录到宿主机中</td></tr><tr><td>create</td><td>Create a new container</td><td>创建一个新的容器，同 run，但不启动容器</td></tr><tr><td>diff</td><td>Inspect changes on a container’s filesystem</td><td>查看 docker 容器变化</td></tr><tr><td>events</td><td>Get real time events from the server</td><td>从 docker 服务获取容器实时事件</td></tr><tr><td>exec</td><td>Run a command in an existing container</td><td>在已存在的容器上运行命令</td></tr><tr><td>export</td><td>Stream the contents of a container as a tar archive</td><td>导出容器的内容流作为一个 tar 归档文件对应 import</td></tr><tr><td>images</td><td>List images</td><td>列出系统当前镜像</td></tr><tr><td>import</td><td>Create a new filesystem image from the contents of a tarball</td><td>从tar包中的内容创建一个新的文件系统映像对应export</td></tr><tr><td>info</td><td>Display system-wide information</td><td>显示系统相关信息</td></tr><tr><td>inspect</td><td>Return low-level information on a container</td><td>查看容器详细信息</td></tr><tr><td>kill</td><td>Kill a running container</td><td>kill 指定 docker 容器</td></tr><tr><td>load</td><td>Load an image from a tar archive</td><td>从一个 tar 包中加载一个镜像对应 save</td></tr><tr><td>login</td><td>Register or Login to the docker registry server</td><td>注册或者登陆一个 docker 源服务器</td></tr><tr><td>logout</td><td>Log out from a Docker registry server</td><td>从当前 Docker registry 退出</td></tr><tr><td>logs</td><td>Fetch the logs of a container</td><td>输出当前容器日志信息</td></tr><tr><td>port</td><td>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</td><td>查看映射端口对应的容器内部源端口</td></tr><tr><td>pause</td><td>Pause all processes within a container</td><td>暂停容器</td></tr><tr><td>ps</td><td>List containers</td><td>列出容器列表</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 日志系统：一条SQL更新语句是如何执行的？</title>
    <link href="/2.%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F.html"/>
    <url>/2.%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F.html</url>
    
    <content type="html"><![CDATA[<h2 id="2-日志系统：一条SQL更新语句是如何执行的？"><a href="#2-日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="2. 日志系统：一条SQL更新语句是如何执行的？"></a>2. 日志系统：一条SQL更新语句是如何执行的？</h2><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块：<strong>redo log（重做日志）和 binlog（归档日志）</strong>。</p><h3 id="2-1-redo-log"><a href="#2-1-redo-log" class="headerlink" title="2.1 redo log"></a>2.1 redo log</h3><p>如果<strong>每一次的更新操作都需要写进磁盘</strong>，然后磁盘也要找到对应的那条记录，然后再更新，整个过程<strong>IO成本、查找成本都很高</strong>。</p><p><strong>WAL</strong>的全称是Write-Ahead Logging，它的关键点就是<strong>先写日志，再写磁盘</strong>。</p><p>当有一条记录需要<strong>更新</strong>的时候，InnoDB引擎就会<strong>先把记录写到redo log</strong>里面，并<strong>更新内存</strong>，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录<strong>更新到磁盘里面</strong>，而这个更新往往是在系统比较<strong>空闲</strong>的时候做。</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是 1GB，那么总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230508202933697.png" alt="image-20230508202933697"></p><p><strong>write pos</strong>是<strong>当前记录的位置</strong>，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。<strong>checkpoint</strong>是<strong>当前要擦除的位置</strong>，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是redo log上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示redo log这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><p> 有了redo log，InnoDB就可以保证<strong>即使数据库发生异常重启，之前提交的记录都不会丢失</strong>，这个能力称为<strong>crash-safe</strong>。</p><h3 id="2-2-binlog"><a href="#2-2-binlog" class="headerlink" title="2.2 binlog"></a>2.2 binlog</h3><p>redo log是InnoDB引擎特有的日志，而<strong>Server层</strong>也有自己的日志，称为binlog（归档日志）。</p><p>这两种日志有以下三点不同。 </p><ol><li><p>redo log是<strong>InnoDB引擎特有</strong>的；binlog是<strong>MySQL的Server层实现</strong>的，所有引擎都可以使用。 </p></li><li><p>redo log是<strong>物理日志</strong>，记录的是“在某个数据页上<strong>做了什么修改</strong>”；binlog是<strong>逻辑日志</strong>，记录的是这个<strong>语句的原始逻辑</strong>，比如“给ID&#x3D;2这一行的c字段加1 ”。 </p></li><li><p>redo log是<strong>循环写</strong>的，空间固定会用完；binlog是可以<strong>追加写入</strong>的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并<strong>不会覆盖</strong>以前的日志。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table T(ID int primary key, c int);<br>mysql&gt; update T set c=c+1 where ID=2;<br></code></pre></td></tr></table></figure><p>执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。 </p><ol><li><p>执行器先<strong>找引擎取ID&#x3D;2这一行</strong>。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 </p></li><li><p>执行器拿到引擎给的行数据，<strong>把这个值加上1</strong>，比如原来是N，现在就是N+1，得到新的一行数据，再<strong>调用引擎接口写入这行新数据</strong>。 </p></li><li><p><strong>引擎</strong>将这行新数据<strong>更新到内存</strong>中，同时将这个更新操作<strong>记录到redo log</strong>里面，此时redo log处于<strong>prepare状态</strong>。然后告知执行器执行完成了，随时可以提交事务。 </p></li><li><p><strong>执行器</strong>生成这个操作的binlog，并把<strong>binlog写入磁盘</strong>。 </p></li><li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成<strong>提交（commit）状态</strong>，更新完成。</p></li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/image-20230508202945483.png" alt="image-20230508202945483"></p><p>将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><h3 id="2-3-两阶段提交"><a href="#2-3-两阶段提交" class="headerlink" title="2.3 两阶段提交"></a>2.3 两阶段提交</h3><p>为什么必须有“两阶段提交”呢？这是为了<strong>让两份日志之间的逻辑一致</strong>。</p><p>当需要数据库<strong>恢复到指定的某一秒</strong>时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做： </p><ul><li><p>首先，找到<strong>最近的一次全量备份</strong>，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； </p></li><li><p>然后，从备份的时间点开始，<strong>将备份的binlog依次取出来</strong>，重放到中午误删表之前的那个时刻。</p></li></ul><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 </p><p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？ </p><ol><li><strong>先写先 redo log后写后 binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。 但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。 然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。 </li><li><strong>先写先 binlog后写后 redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是 1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是<strong>让这两个状态保持逻辑上的一致</strong>。 </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 基础架构：一条SQL查询语句是如何执行的？</title>
    <link href="/1.%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F.html"/>
    <url>/1.%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-基础架构：一条SQL查询语句是如何执行的？"><a href="#1-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="1. 基础架构：一条SQL查询语句是如何执行的？"></a>1. 基础架构：一条SQL查询语句是如何执行的？</h2><p>下面是<strong>MySQL的基本架构</strong>示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p><p><img src="https://cdn.jsdelivr.net/gh/wyn04/my-pic-bed/f6b1fbd6cbe8b2592a8d535221e7b51d-20230504093007977.png" alt="image-20230308152659467"></p><p>MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分。</p><ol><li><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数<strong>核心服务功能</strong>，以及所有的<strong>内置函数</strong>（如日期、时间、数学和加密函数等），所有<strong>跨存储引擎的功能</strong>都在这一层实现，比如存储过程、触发器、视图等。 </p></li><li><p>存储引擎层负责<strong>数据的存储和提取</strong>。其架构模式是插件式的，支持InnoDB、MyISAM、 Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。也就是说，你执行create table建表的时候，如果不指定引擎类型，<strong>默认使用的就是InnoDB</strong>。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在<code>create table</code>语句中使用<code>engine=memory</code>, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p></li></ol><h3 id="1-1-连接器"><a href="#1-1-连接器" class="headerlink" title="1.1 连接器"></a>1.1 连接器</h3><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h$ip -P$port -u$user -p<br></code></pre></td></tr></table></figure><p>连接命令中的mysql是<strong>客户端工具</strong>，用来跟服务端建立连接。在完成经典的TCP握手后，连接器 就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。 </p><ul><li><p>如果用户名或密码不对，你就会收到一个**”Access denied for user”的错误**，然后客户端程序结束执行。 </p></li><li><p>如果用户名密码认证通过，连接器会到<strong>权限表里面查出你拥有的权限</strong>。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有<strong>再新建的连接才会使用新的权限设置</strong>。</p></li></ul><p>客户端如果太<strong>长时间没动静</strong>，连接器就会<strong>自动将它断开</strong>。这个时间是由参数<code>wait_timeout</code>控制的，默认值是8小时。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <code>Lost connection to MySQL server during query</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p><ul><li><strong>长连接</strong>是指连接成功后，如果客户端<strong>持续有请求</strong>，则一直使用<strong>同一个连接</strong>。</li><li><strong>短连接</strong>则是指每次执行完很少的<strong>几次查询就断开连接</strong>，下次查询再重新建立一个。</li></ul><p><strong>建立连接的过程通常是比较复杂</strong>的，所以建议在使用中要尽量减少建立连接的动作，也就是<strong>尽量使用长连接</strong>。</p><p>但是全部使用长连接后，MySQL占用内存涨得特别快，这是因为MySQL在执行过程中<strong>临时使用的内存是管理在连接对象里面的</strong>。这些资源会在<strong>连接断开的时候才释放</strong>。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。 </p><ol><li><p><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断<strong>执行过一个占用内存的大查询后</strong>，断开连接，之后要查询再重连。 </p></li><li><p>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行<code>mysql_reset_connection</code>来<strong>重新初始化连接资源</strong>。这个过程<strong>不需要重连</strong>和重新做权限验证，但是会<strong>将连接恢复到刚刚创建完时的状态</strong>。</p></li></ol><h3 id="1-2-查询缓存"><a href="#1-2-查询缓存" class="headerlink" title="1.2 查询缓存"></a>1.2 查询缓存</h3><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。<strong>之前执行过的语句及其结果</strong>可能会以<strong>key-value对</strong>的形式，被直接缓存在内存中。<strong>key是查询的语句，value是查询的结果。</strong>如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个<strong>效率会很高</strong>。 </p><p>但是大多数情况下<strong>建议不要使用查询缓存</strong>：查询缓存的<strong>失效非常频繁</strong>，只要有对一个<strong>表的更新</strong>，这个表上所有的<strong>查询缓存都会被清空</strong>。对于<strong>更新压力大的数据库</strong>来说，查询缓存的命中率会非常低。除非你的业务就是有一张<strong>静态表</strong>，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>在MySQL也提供了这种“按需使用”的方式。你可以将参数<code>query_cache_type</code>设置成 <code>DEMAND</code>，这样对于<strong>默认的SQL语句都不使用查询缓存</strong>。而对于你<strong>确定要使用查询缓存的语 句</strong>，可以用<code>SQL_CACHE</code>显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select SQL_CACHE * from T where ID=10；<br></code></pre></td></tr></table></figure><p>MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。 </p><h3 id="1-3-分析器"><a href="#1-3-分析器" class="headerlink" title="1.3 分析器"></a>1.3 分析器</h3><p>首先，MySQL需要<strong>知道你要做什么</strong>，因此 需要对SQL语句做解析。 </p><ul><li><p>分析器先会做<strong>“词法分析”</strong>。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的<strong>字符串分别是什么</strong>，代表什么。MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别 成“表名T”，把字符串“ID”识别成“列ID”。 </p></li><li><p>做完了这些识别以后，就要做<strong>“语法分析”</strong>。根据词法分析的结果，语法分析器会根据语法规则， 判断你输入的这个SQL语句<strong>是否满足MySQL语法</strong>。 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个 语句select少打了开头的字母“s”。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; elect * from t where ID=1; <br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1 <br></code></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h3 id="1-4-优化器"><a href="#1-4-优化器" class="headerlink" title="1.4 优化器"></a>1.4 优化器</h3><p>优化器是在表里面有<strong>多个索引</strong>的时候，决定使用哪个索引；或者在一个语句有<strong>多表关联</strong>（join） 的时候，决定各个表的连接顺序。</p><p>比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;<br></code></pre></td></tr></table></figure><ul><li><p>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。 </p></li><li><p>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</p></li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。 </p><h3 id="1-5-执行器"><a href="#1-5-执行器" class="headerlink" title="1.5 执行器"></a>1.5 执行器</h3><p>MySQL通过<strong>分析器</strong>知道了你要<strong>做什么</strong>，通过<strong>优化器</strong>知道了该<strong>怎么做</strong>，于是就进入了执行器阶 段，开始执行语句。</p><p>要先判断一下你对这个表T有没有<strong>执行查询的权限</strong>，如果没有，就会返回没有权限的错误，如下所示。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from T where ID=10; <br>ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;<br></code></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去<strong>使用这个引擎提供的接口</strong>。 </p><p>比如我们这个例子中的表T中，ID字段<strong>没有索引</strong>，那么执行器的执行流程是这样的： </p><ol><li><p>调用InnoDB引擎接口取这个表的<strong>第一行</strong>，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中； </p></li><li><p>调用引擎接口取<strong>“下一行”</strong>，重复相同的判断逻辑，直到取到这个表的最后一行。 </p></li><li><p>执行器将上述<strong>遍历</strong>过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p></li></ol><p>至此，这个语句就执行完成了。 </p><p>对于<strong>有索引</strong>的表，执行的逻辑也差不多。第一次调用的是<strong>“取满足条件的第一行”</strong>这个接口，之后循环取<strong>“满足条件的下一行”</strong>这个接口，这些接口都是引擎中已经定义好的。 </p><p>你会在数据库的慢查询日志中看到一个<code>rows_examined</code>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
